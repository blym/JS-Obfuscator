{"version":3,"sources":["webpack://JavaScriptObfuscator/webpack/bootstrap","webpack://JavaScriptObfuscator/external \"inversify\"","webpack://JavaScriptObfuscator/external \"tslib\"","webpack://JavaScriptObfuscator/./src/container/ServiceIdentifiers.ts","webpack://JavaScriptObfuscator/./src/node/NodeGuards.ts","webpack://JavaScriptObfuscator/./src/decorators/Initializable.ts","webpack://JavaScriptObfuscator/./src/node/NodeUtils.ts","webpack://JavaScriptObfuscator/./src/node/NodeFactory.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/TransformationStage.ts","webpack://JavaScriptObfuscator/./src/node-transformers/AbstractNodeTransformer.ts","webpack://JavaScriptObfuscator/external \"estraverse\"","webpack://JavaScriptObfuscator/./src/node/NodeMetadata.ts","webpack://JavaScriptObfuscator/./src/enums/ObfuscationTarget.ts","webpack://JavaScriptObfuscator/./src/container/InversifyContainerFacade.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack://JavaScriptObfuscator/./src/node/NodeAppender.ts","webpack://JavaScriptObfuscator/./src/node/NodeStatementUtils.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/NodeTransformer.ts","webpack://JavaScriptObfuscator/./src/enums/event-emitters/ObfuscationEvent.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/StringArrayEncoding.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorFacade.ts","webpack://JavaScriptObfuscator/./src/enums/node/NodeType.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/utils/Utils.ts","webpack://JavaScriptObfuscator/./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/enums/source-map/SourceMapMode.ts","webpack://JavaScriptObfuscator/external \"@gradecam/tsenum\"","webpack://JavaScriptObfuscator/./src/options/presets/NoCustomNodes.ts","webpack://JavaScriptObfuscator/./src/utils/NumberUtils.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"escodegen\"","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AbstractPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableNoEvalTemplate.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/storages/MapStorage.ts","webpack://JavaScriptObfuscator/./src/options/presets/Default.ts","webpack://JavaScriptObfuscator/./src/enums/StringSeparator.ts","webpack://JavaScriptObfuscator/./src/enums/analyzers/calls-graph-analyzer/CalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/ASTParserFacade.ts","webpack://JavaScriptObfuscator/external \"chalk\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ObjectExpressionKeysTransformerCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/utils/RandomGenerator.ts","webpack://JavaScriptObfuscator/external \"reflect-metadata\"","webpack://JavaScriptObfuscator/./src/logger/Logger.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingPrefix.ts","webpack://JavaScriptObfuscator/./src/container/modules/analyzers/AnalyzersModule.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/CallsGraphAnalyzer.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/calls-graph-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer.ts","webpack://JavaScriptObfuscator/./src/analyzers/scope-analyzer/ScopeAnalyzer.ts","webpack://JavaScriptObfuscator/external \"eslint-scope\"","webpack://JavaScriptObfuscator/./src/analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack://JavaScriptObfuscator/external \"acorn\"","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/BasePropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/SplitStringTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/object-expression-keys-transformer-nodes/BasePropertiesExtractorObjectExpressionHostNode.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate1.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate2.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack://JavaScriptObfuscator/./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/CustomNodeFormatter.ts","webpack://JavaScriptObfuscator/external \"string-template\"","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack://JavaScriptObfuscator/./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/SingleNodeCallControllerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack://JavaScriptObfuscator/./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack://JavaScriptObfuscator/./src/templates/AtobTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/Rc4Template.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/generators/GeneratorsModule.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/DictionaryIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeLexicalScopeUtils.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ScopeIdentifiersTransformer.ts","webpack://JavaScriptObfuscator/./src/container/modules/options/OptionsModule.ts","webpack://JavaScriptObfuscator/./src/options/Options.ts","webpack://JavaScriptObfuscator/external \"class-validator\"","webpack://JavaScriptObfuscator/./src/options/ValidationErrorsFormatter.ts","webpack://JavaScriptObfuscator/./src/options/OptionsNormalizer.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DomainLockRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/InputFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SeedRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SelfDefendingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SplitStringsChunkLengthRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/EvalCallExpressionTransformer.ts","webpack://JavaScriptObfuscator/external \"js-string-escape\"","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/MetadataTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ReservedStringObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/VariablePreserveTransformer.ts","webpack://JavaScriptObfuscator/./src/container/modules/storages/StoragesModule.ts","webpack://JavaScriptObfuscator/./src/storages/control-flow/ControlFlowStorage.ts","webpack://JavaScriptObfuscator/./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack://JavaScriptObfuscator/./src/storages/string-array/StringArrayStorage.ts","webpack://JavaScriptObfuscator/./src/container/modules/utils/UtilsModule.ts","webpack://JavaScriptObfuscator/./src/utils/ArrayUtils.ts","webpack://JavaScriptObfuscator/./src/utils/CryptUtils.ts","webpack://JavaScriptObfuscator/external \"md5\"","webpack://JavaScriptObfuscator/external \"chance\"","webpack://JavaScriptObfuscator/./src/utils/EscapeSequenceEncoder.ts","webpack://JavaScriptObfuscator/./src/utils/LevelledTopologicalSorter.ts","webpack://JavaScriptObfuscator/./src/utils/NodeTransformerNamesGroupsBuilder.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscator.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingMessage.ts","webpack://JavaScriptObfuscator/./src/event-emitters/ObfuscationEventEmitter.ts","webpack://JavaScriptObfuscator/external \"eventemitter3\"","webpack://JavaScriptObfuscator/./src/source-code/ObfuscatedCode.ts","webpack://JavaScriptObfuscator/./src/source-code/SourceCode.ts","webpack://JavaScriptObfuscator/./src/node-transformers/TransformersRunner.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/VisitorDirection.ts","webpack://JavaScriptObfuscator/./src/cli/JavaScriptObfuscatorCLI.ts","webpack://JavaScriptObfuscator/external \"path\"","webpack://JavaScriptObfuscator/external \"fs\"","webpack://JavaScriptObfuscator/./index.cli.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorCLIFacade.ts","webpack://JavaScriptObfuscator/external \"commander\"","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ArraySanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/BooleanSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/IdentifierNamesGeneratorSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/ObfuscatingTargetSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/SourceMapModeSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/sanitizers/StringArrayEncodingSanitizer.ts","webpack://JavaScriptObfuscator/./src/cli/utils/CLIUtils.ts","webpack://JavaScriptObfuscator/external \"mkdirp\"","webpack://JavaScriptObfuscator/./src/cli/utils sync","webpack://JavaScriptObfuscator/./src/cli/utils/SourceCodeReader.ts","webpack://JavaScriptObfuscator/external \"multimatch\""],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ServiceIdentifiers","NodeGuards","node","type","NodeType","ArrayPattern","ArrowFunctionExpression","AssignmentExpression","AssignmentPattern","AwaitExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ClassDeclaration","id","ContinueStatement","ExpressionStatement","ExportNamedDeclaration","isForStatementNode","isForInStatementNode","isForOfStatementNode","ForStatement","ForInStatement","ForOfStatement","isFunctionDeclarationNode","isFunctionExpressionNode","isArrowFunctionExpressionNode","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","ImportDeclaration","ImportSpecifier","parentNode","parentNodeIsLabeledStatementNode","isLabeledStatementNode","label","parentNodeIsContinueStatementNode","isContinueStatementNode","parentNodeIsBreakStatementNode","isBreakStatementNode","LabeledStatement","Literal","MemberExpression","MethodDefinition","undefined","isProgramNode","isFunctionNode","isNodeWithLexicalScope","isBlockStatementNode","nodesWithLexicalStatements","includes","isSwitchCaseNode","Boolean","leadingComments","trailingComments","ObjectPattern","ObjectExpression","Program","Property","isPropertyNode","computed","isMemberExpressionNode","isMethodDefinitionNode","RestElement","ReturnStatement","Super","SwitchCase","TaggedTemplateExpression","TemplateLiteral","UnaryExpression","isDirectiveNode","directive","VariableDeclaration","VariableDeclarator","WhileStatement","defaultDescriptor","configurable","initializeTargetMetadata","metadataKey","metadataValue","target","Reflect","hasMetadata","defineMetadata","initializeMethodName","decoratorName","keys","this","propertyKey","initializeMethod","Error","Set","ownPropertyNames","getOwnPropertyNames","prohibitedPropertyNames","forEach","propertyName","initializablePropertiesSet","getMetadata","wrappedMethodsSet","has","methodDescriptor","getOwnPropertyDescriptor","originalMethod","apply","arguments","add","wrapTargetMethodsInInitializedCheck","result","wrapInitializeMethodInInitializeCheck","initializablePropertyMetadataKey","toString","propertyDescriptor","set","newVal","wrapInitializableProperty","NodeUtils","literalNode","content","raw","precedence","escodegen","Precedence","Primary","astTree","parentizeAst","cloneRecursive","code","structure","ASTParserFacade","parse","ecmaVersion","sourceType","estraverse","replace","enter","parentizeNode","isLiteralNode","addXVerbatimPropertyTo","NodeMetadata","ignoredNode","body","reduce","generate","sourceMapWithCode","unaryExpressionNode","isUnaryExpressionNode","argument","getUnaryExpressionArgumentNode","copy","clonedValue","RegExp","Array","isArray","map","NodeFactory","metadata","elements","ArrayExpression","operator","left","right","BinaryExpression","callee","args","expression","functionName","params","identifierNode","generator","test","consequent","alternate","LogicalExpression","kind","static","properties","method","shorthand","discriminant","cases","SwitchStatement","prefix","argumentExpr","UpdateExpression","declarations","init","AbstractCustomNode","identifierNamesGeneratorFactory","customNodeFormatter","randomGenerator","options","cachedNode","identifierNamesGenerator","nodeTemplate","getNodeTemplate","formatStructure","getNodeStructure","getRandomGenerator","pickone","globalVariableTemplateFunctions","GlobalVariableTemplate1","GlobalVariableTemplate2","injectable","inject","Factory__IIdentifierNamesGenerator","ICustomNodeFormatter","IRandomGenerator","IOptions","TransformationStage","AbstractNodeTransformer","assign","ObfuscationTarget","MakeEnum","Browser","BrowserNoEval","Node","container","Container","serviceIdentifier","context","bindingName","getNamed","cache","Map","dependencies","cachedDependencies","dependency","index","constructor","named","sourceCode","sourceMap","ISourceCode","toDynamicValue","SourceCode","inSingletonScope","TInputOptions","ILogger","to","Logger","IJavaScriptObfuscator","JavaScriptObfuscator","ITransformersRunner","TransformersRunner","IObfuscatedCode","ObfuscatedCode","Factory__IObfuscatedCode","toFactory","obfuscatedCodeAsString","sourceMapAsString","obfuscatedCode","initialize","IObfuscationEventEmitter","ObfuscationEventEmitter","load","analyzersModule","controlFlowTransformersModule","convertingTransformersModule","customNodesModule","finalizingTransformersModule","generatorsModule","nodeTransformersModule","obfuscatingTransformersModule","optionsModule","preparingTransformersModule","storagesModule","utilsModule","unbindAll","ControlFlowCustomNode","NodeAppender","nodeWithStatements","statements","parentizeScopeStatementsBeforeAppend","setScopeStatements","getScopeStatements","callsGraphData","bodyStatements","targetBlockScope","length","getOptimalBlockScope","prepend","deep","Infinity","firstCall","callsGraph","indexInScopeStatement","indexOf","insertAtIndex","slice","statement","NodeStatementUtils","getParentNodesWithStatementsRecursive","getSiblingStatementByOffset","ReferenceError","isNodeWithStatements","getRootStatementOfNode","getScopeOfNode","maxSize","nodesWithStatements","depth","isNodeWithLexicalScopeStatements","push","offset","scopeNode","scopeBody","indexInScope","NodeTransformer","ObfuscationEvent","CustomNode","StringArrayEncoding","Base64","Rc4","JavaScriptObfuscatorFacade","inputOptions","inversifyContainerFacade","InversifyContainerFacade","obfuscate","unload","version","AbstractCustomNodeGroup","appendEvent","customNodes","customNodeName","callback","customNode","callsGraphLength","getRandomInteger","Math","max","round","Utils","url","domain","split","hexadecimalPrefix","IdentifierNamesGenerator","DictionaryIdentifierNamesGenerator","HexadecimalIdentifierNamesGenerator","MangledIdentifierNamesGenerator","SourceMapMode","Inline","Separate","NO_ADDITIONAL_NODES_PRESET","freeze","compact","controlFlowFlattening","controlFlowFlatteningThreshold","deadCodeInjection","deadCodeInjectionThreshold","debugProtection","debugProtectionInterval","disableConsoleOutput","domainLock","exclude","identifiersPrefix","identifiersDictionary","inputFileName","log","renameGlobals","reservedNames","reservedStrings","rotateStringArray","seed","selfDefending","shuffleStringArray","sourceMapBaseUrl","sourceMapFileName","sourceMapMode","splitStrings","splitStringsChunkLength","stringArray","stringArrayEncoding","stringArrayThreshold","transformObjectKeys","unicodeEscapeSequence","dec","number","IdentifierObfuscatingReplacer","AbstractObfuscatingReplacer","AbstractCalleeDataExtractor","AbstractControlFlowReplacer","controlFlowCustomNodeFactory","replacerDataByControlFlowStorageId","identifierDataByControlFlowStorageId","controlFlowStorageId","storageKeysById","controlFlowStorage","replacerId","usingExistingIdentifierChance","getStorageId","getStorageKeysByIdForCurrentStorage","storageKeysForCurrentId","getMathRandom","generateStorageKey","getRandomString","getStorage","storageKey","Factory__IControlFlowCustomNode","AbstractPropertiesExtractor","cachedHostNodesWithStatementsMap","cachedHostStatementsMap","propertyNode","propertyKeyNode","isIdentifierNode","isObjectPatternNode","isArrayPatternNode","isAssignmentPatternNode","isRestElementNode","memberExpressionHostNode","propertiesLength","expressionStatements","removablePropertyIds","propertyValue","isProhibitedPattern","propertyKeyName","getPropertyNodeKeyName","memberExpressionProperty","memberExpressionNode","expressionStatementNode","assignmentExpressionNode","isObjectExpressionNode","transformObjectExpressionNode","objectExpressionNode","filter","extractPropertiesToExpressionStatements","hostStatement","getHostStatement","hostNodeWithStatements","getHostNodeWithStatements","filterExtractedObjectExpressionProperties","insertAfter","AbstractIdentifierNamesGenerator","preservedNames","notReservedName","some","reservedName","exec","MapStorage","storage","storageId","storageValue","size","mergeId","initializable","postConstruct","DEFAULT_PRESET","config","StringSeparator","CalleeDataExtractor","ControlFlowReplacer","ExpressionWithOperatorControlFlowReplacer","super","leftExpression","rightExpression","controlFlowStorageCallCustomNode","ExpressionWithOperatorControlFlowStorageCallNode","statementNode","getNode","isExpressionStatementNode","input","sourceTypeLength","sourceTypes","parseType","error","processParsingError","message","loc","inputConfig","comments","onComment","program","acorn","errorMessage","position","line","column","errorLine","startErrorIndex","nearestSymbolsCount","endErrorIndex","min","formattedPointer","colorError","formattedCodeSlice","substring","red","DeadCodeInjectionCustomNode","PropertiesExtractor","ObjectExpressionKeysTransformerCustomNode","CustomNodeGroup","LiteralObfuscatingReplacer","ObfuscatingGuard","ConditionalCommentObfuscatingGuard","obfuscationAllowedForCurrentNode","obfuscationAllowedForNextNode","comment","obfuscationEnableCommentRegExp","obfuscationDisableCommentRegExp","isNodeWithComments","checkComments","commentsLength","obfuscationAllowed","RandomGenerator","Chance","getRawSeed","integer","pool","randomGeneratorPool","string","inputSeed","getInputSeed","getSourceCode","loggingLevelColor","loggingPrefix","loggingMessage","processedMessage","console","colorInfo","LoggingPrefix","Base","colorSuccess","colorWarn","cyan","green","yellow","ContainerModule","ICallsGraphAnalyzer","CallsGraphAnalyzer","IPrevailingKindOfVariablesAnalyzer","PrevailingKindOfVariablesAnalyzer","IScopeAnalyzer","ScopeAnalyzer","IStringArrayStorageAnalyzer","StringArrayStorageAnalyzer","ICalleeDataExtractor","FunctionDeclarationCalleeDataExtractor","whenTargetNamed","FunctionExpressionCalleeDataExtractor","ObjectExpressionCalleeDataExtractor","Factory__ICalleeDataExtractor","getCacheFactory","calleeDataExtractorFactory","blockScopeBodyLength","lastIndex","limitThresholdActivationIndex","limitThresholdActivationLength","limitIndex","limitThreshold","analyzeRecursive","blockScopeBody","getLimitIndex","blockScopeBodyNode","traverse","isCallExpressionNode","getParentNodeWithStatements","VisitorOption","Skip","analyzeCallExpressionNode","callExpressionNode","calleeDataExtractorsList","calleeDataExtractorName","calleeData","extract","calleeBlockStatement","getCalleeBlockStatement","targetNode","Break","isVariableDeclaratorNode","nextItemInCallsChain","isTargetPropertyNodeWithIdentifierKey","isTargetPropertyNodeWithLiteralKey","objectMembersCallsChain","createObjectMembersCallsChain","functionExpressionName","currentChain","memberExpression","unshift","objectName","shift","findCalleeBlockStatement","objectExpressionProperties","isValidTargetPropertyNode","arrayUtils","prevailingKindOfVariables","defaultKindOfVariables","variableKinds","isVariableDeclarationNode","findMostOccurringElement","IArrayUtils","scopeManager","range","attachMissingRanges","eslintScope","analyze","eslintScopeOptions","nodejsScope","scope","acquire","isRootNode","optimistic","stringArrayStorage","stringArrayStorageData","isIgnoredNode","analyzeLiteralNode","shouldAddValueToStringArray","getOrThrow","minimumLengthForStringArray","TStringArrayStorage","INodeTransformer","BlockStatementControlFlowTransformer","DeadCodeInjectionTransformer","FunctionControlFlowTransformer","IControlFlowReplacer","BinaryExpressionControlFlowReplacer","CallExpressionControlFlowReplacer","LogicalExpressionControlFlowReplacer","StringLiteralControlFlowReplacer","Factory__IControlFlowReplacer","binaryExpressionNode","binaryExpressionFunctionCustomNode","BinaryExpressionFunctionNode","insertCustomNodeToControlFlowStorage","getControlFlowStorageCallNode","isBreakOrContinueStatement","isVariableDeclarationWithLetOrConstKind","isClassDeclaration","isClassDeclarationNode","blockStatementNode","canTransform","isWhileStatementNode","isProhibitedStatementNode","transformationStage","ControlFlowFlattening","leave","transformNode","canTransformBlockStatementNode","blockStatementBody","originalKeys","createWithRange","shuffledKeys","shuffle","originalKeysIndexesInShuffledArray","blockStatementControlFlowFlatteningCustomNode","BlockStatementControlFlowFlatteningNode","newBlockStatementNode","String","callExpressionFunctionCustomNode","CallExpressionFunctionNode","expressionArguments","CallExpressionControlFlowStorageCallNode","deadCodeInjectionCustomNodeFactory","transformersRunner","deadCodeInjectionRootAstHostNodeSet","collectedBlockStatements","collectedBlockStatementsTotalLength","isAwaitExpressionNode","isSuperNode","slicedBody","hostBlockStatementNode","functionDeclarationName","isScopeHoistedFunctionDeclaration","nestedBlockStatementsCount","isValidBlockStatementNode","maxNestedBlockStatementsCount","isProhibitedNodeInsideCollectedBlockStatement","isScopeHoistingFunctionDeclaration","DeadCodeInjection","analyzeNode","Finalizing","isDeadCodeInjectionRootAstHostNode","restoreNode","programNode","clonedBlockStatementNode","clone","isValidCollectedBlockStatementNode","transformedBlockStatementNode","makeClonedBlockStatementNodeUnique","minCollectedBlockStatementsCount","isValidWrappedBlockStatementNode","maxInteger","randomIndex","randomBlockStatementNode","splice","replaceBlockStatementNode","deadCodeInjectionRootAstHostNode","hostNodeFirstStatement","hostNode","functionExpressionNode","transform","transformersToRenameBlockScopeIdentifiers","Obfuscating","functionDeclarationNode","deadCodeInjectionRootAstHostNodeName","blockStatementDeadCodeInjectionCustomNode","BlockStatementDeadCodeInjectionNode","LabeledStatementTransformer","ScopeIdentifiersTransformer","Factory__IDeadCodeInjectionCustomNode","controlFlowStorageFactory","controlFlowReplacerFactory","controlFlowData","visitedFunctionNodes","hostNodesWithControlFlowNode","functionNode","getHostNode","getControlFlowStorage","transformFunctionBody","getLength","controlFlowStorageCustomNode","ControlFlowStorageNode","hostControlFlowStorage","mergeWith","functionNodeBody","blockScopesOfNode","getParentNodesWithStatements","pop","hostNodeSearchMinDepth","hostNodeSearchMaxDepth","isVisitedFunctionNode","controlFlowReplacersMap","controlFlowReplacerName","Factory__TControlFlowStorage","logicalExpressionNode","checkForProhibitedExpressions","logicalExpressionFunctionCustomNode","LogicalExpressionFunctionNode","expressionNode","nodeForCheck","literalFunctionCustomNode","StringLiteralNode","StringLiteralControlFlowStorageCallNode","MemberExpressionTransformer","MethodDefinitionTransformer","ObjectExpressionKeysTransformer","ObjectExpressionTransformer","SplitStringTransformer","TemplateLiteralTransformer","IPropertiesExtractor","AssignmentExpressionPropertiesExtractor","BasePropertiesExtractor","VariableDeclaratorPropertiesExtractor","Factory__IPropertiesExtractor","isIfStatementNode","isForStatementTypeNode","hostParentNode","leftNode","isProhibitedHostParent","objectExpressionKeysTransformerCustomNodeFactory","newObjectExpressionHostNode","getObjectExpressionHostNode","newObjectExpressionIdentifier","getObjectExpressionIdentifierNode","statementsToInsert","insertBefore","objectExpressionHostCustomNode","BasePropertiesExtractorObjectExpressionHostNode","objectExpressionHostNode","newObjectExpressionIdentifierNode","Factory__IObjectExpressionKeysTransformerCustomNode","Converting","methodDefinitionNode","replaceIdentifierKey","replaceLiteralKey","keyNode","ignoredNames","propertiesExtractorFactory","transformNodeWithBaseExtractor","propertiesExtractorName","propertiesExtractorsMap","escapeSequenceEncoder","transformComputedProperty","transformBaseProperty","getPropertyKeyValue","inputValue","encode","IEscapeSequenceEncoder","runAfter","chunkSize","chunksCount","ceil","chunks","nextChunkStartIndex","chunkIndex","substr","stringChunks","chunkString","transformStringChunksToBinaryExpressionNode","lastChunk","lastChunkLiteralNode","isTemplateLiteralNode","isTaggedTemplateExpressionNode","isValidTemplateLiteralNode","templateLiteralNode","templateLiteralExpressions","expressions","transformedNode","nodes","quasis","templateElement","cooked","isLiteralNodeWithStringValue","root","isProhibitedObjectExpressionNode","variableDeclaratorNode","hostVariableDeclarator","getHostVariableDeclaratorNode","hostVariableDeclaration","getHostVariableDeclarationNode","indexOfDeclarator","declaratorsAfterCurrentDeclarator","variableDeclarator","ICustomNode","ConsoleOutputDisableExpressionNode","DebugProtectionFunctionCallNode","DebugProtectionFunctionIntervalNode","DebugProtectionFunctionNode","DomainLockNode","NodeCallsControllerFunctionNode","SelfDefendingUnicodeNode","StringArrayCallsWrapper","StringArrayNode","StringArrayRotateFunctionNode","Newable__ICustomNode","toConstructor","ICustomNodeGroup","ConsoleOutputCustomNodeGroup","DebugProtectionCustomNodeGroup","DomainLockCustomNodeGroup","SelfDefendingCustomNodeGroup","StringArrayCustomNodeGroup","Factory__ICustomNode","getFactory","getConstructorFactory","Factory__ICustomNodeGroup","CustomNodeFormatter","customNodeFactory","BeforeObfuscation","randomCallsGraphIndex","getRandomCallsGraphIndex","appendCustomNodeIfExist","appendToOptimalBlockScope","targetNodeWithStatements","callsControllerFunctionName","consoleOutputDisableExpressionNode","nodeCallsControllerFunctionNode","append","programBodyLength","debugProtectionFunctionName","debugProtectionFunctionNode","debugProtectionFunctionCallNode","debugProtectionFunctionIntervalNode","domainLockNode","AfterObfuscation","selfDefendingUnicodeNode","stringArrayNode","stringArrayCallsWrapper","stringArrayRotateFunctionNode","stringArrayName","getStorageName","stringArrayCallsWrapperName","getStorageCallsWrapperName","stringArrayRotationAmount","getRotationAmount","variableDeclarationNode","returnStatementNode","controllerIdentifierName","indexIdentifierName","join","whileStatementNode","switchStatementNode","updateExpressionNode","isReturnStatementNode","continueStatement","switchCaseNode","breakStatement","random1","random2","leftString","rightString","ifStatementNode","controlFlowStorageName","controlFlowStorageKey","calleeIdentifier","argumentsLength","propertyNodes","from","convertCodeToStructure","globalVariableTemplate","getGlobalVariableTemplate","GlobalVariableNoEvalTemplate","formatTemplate","ConsoleOutputDisableExpressionTemplate","consoleLogDisableFunctionName","singleNodeCallControllerFunctionName","prevailingKindOfVariablesAnalyzer","getPrevailingKind","template","mapping","DebugProtectionFunctionCallTemplate","DebugProtectionFunctionIntervalTemplate","debuggerTemplate","DebuggerTemplate","DebuggerTemplateNoEval","DebugProtectionFunctionTemplate","cryptUtils","domainsString","hiddenDomainsString","diff","hideString","DomainLockNodeTemplate","domainLockFunctionName","domains","ICryptUtils","leftValue","rightValue","SingleNodeCallControllerTemplate","getObfuscatedCode","SelfDefendingTemplate","selfDefendingFunctionName","decodeNodeTemplate","getDecodeStringArrayTemplate","StringArrayCallsWrapperTemplate","atobPolyfill","AtobTemplate","decodeStringArrayTemplate","selfDefendingCode","StringArrayRc4DecodeNodeTemplate","rc4Polyfill","Rc4Template","StringArrayBase64DecodeNodeTemplate","rc4BytesIdentifier","statesIdentifier","newStateIdentifier","firstStateIdentifier","secondStateIdentifier","checkStateIdentifier","runStateIdentifier","getStateIdentifier","stateResultIdentifier","initializedIdentifier","base64DecodeFunctionIdentifier","dataIdentifier","rc4Identifier","onceIdentifier","StringArrayTemplate","timesName","whileFunctionName","StringArrayRotateFunctionTemplate","NumberUtils","toHex","literalValue","IIdentifierNamesGenerator","cachedIdentifierNamesGenerator","identifierNameGeneratorFactory","identifierNamesSet","getInitialIdentifierNames","identifiersIterator","values","identifierName","newIdentifierName","isSuccess","character","toUpperCase","toLowerCase","iteratorResult","next","done","getIncrementedIdentifierNames","identifierNames","formattedIdentifierNames","incrementIdentifierName","randomVariableNameSet","nameLength","randomInteger","hexadecimalNumber","prefixLength","baseNameLength","baseIdentifierNameLength","baseIdentifierName","previousMangledName","initMangledNameCharacter","generateNewMangledName","mangledName","isValidIdentifierName","newMangledName","nameSequence","zeroSequence","num","repeat","charAt","indexInSequence","Factory__INodeTransformer","LiteralTransformer","IObfuscatingReplacer","BooleanLiteralObfuscatingReplacer","NumberLiteralObfuscatingReplacer","StringLiteralObfuscatingReplacer","IIdentifierObfuscatingReplacer","BaseIdentifierObfuscatingReplacer","Factory__IObfuscatingReplacer","Factory__IIdentifierObfuscatingReplacer","blockScopesMap","lexicalScopeNode","namesMap","isReservedName","generateWithPrefix","preserveName","getFalseUnaryExpressionNode","arrayExpressionNode","getTrueUnaryExpressionNode","identifierObfuscatingReplacerFactory","identifierObfuscatingReplacer","labeledStatementNode","NodeLexicalScopeUtils","getLexicalScope","storeLabeledStatementName","replaceLabeledStatementName","storeLocalName","isLabelIdentifierNode","newIdentifier","getLexicalScopesRecursive","nodesWithLexicalScope","literalObfuscatingReplacerFactory","stringArrayStorageAnalyzer","isReplacedLiteral","isProhibitedNode","newLiteralNode","isImportDeclarationNode","numberLiteralCache","rawValue","isCeil","nodesCache","hexadecimalIndex","hexadecimalLiteralNode","replacedLiteral","rc4KeyLiteralNode","stringArrayStorageCallsWrapperName","shuffleStorage","rotateStorage","stringArrayStorageItemData","getItemDataForLiteralNode","cacheKey","resultNode","replaceWithStringArrayCallNode","replaceWithLiteralNode","decodeKey","callExpressionArgs","getHexadecimalLiteralNode","getRc4KeyLiteralNode","stringArrayIdentifierNode","scopeAnalyzer","lexicalScopesWithObjectPatternWithoutDeclarationMap","globalScope","acquireScope","traverseScopeVariables","lexicalScope","variableScope","nodeWithLexicalScope","isNodeWithBlockLexicalScope","block","isGlobalDeclaration","globalScopeNames","variable","variables","argumentsVariableName","defs","every","definition","transformScopeVariableIdentifiers","childScope","childScopes","identifier","identifiers","isReplaceableIdentifierNode","storeIdentifierName","replaceIdentifierName","storeGlobalName","references","reference","defaults","isProhibitedPropertyNode","isProhibitedClassDeclarationNameIdentifierNode","isProhibitedExportNamedClassDeclarationIdentifierNode","isProhibitedExportNamedFunctionDeclarationIdentifierNode","isProhibitedExportNamedVariableDeclarationIdentifierNode","isProhibitedImportSpecifierNode","isProhibitedVariableNameUsedInObjectPatternNode","isExportNamedDeclarationNode","isImportSpecifierNode","imported","local","isLexicalScopeHasObjectPatternWithoutDeclaration","isProhibitedVariableDeclaration","isAssignmentExpressionNode","Options","IOptionsNormalizer","OptionsNormalizer","optionsNormalizer","errors","validateSync","validatorOptions","ValidationErrorsFormatter","format","normalize","validationError","IsBoolean","IsNumber","Min","Max","IsArray","ArrayUnique","IsString","each","IsIn","ValidateIf","ArrayNotEmpty","IsUrl","require_protocol","require_tld","require_valid_protocol","errorMessages","formatWithNestedConstraints","constraints","constraint","normalizedOptions","normalizerRule","normalizerRules","ControlFlowFlatteningThresholdRule","DeadCodeInjectionRule","DeadCodeInjectionThresholdRule","DomainLockRule","InputFileNameRule","SeedRule","SelfDefendingRule","SourceMapBaseUrlRule","SourceMapFileNameRule","SplitStringsChunkLengthRule","StringArrayRule","StringArrayEncodingRule","StringArrayThresholdRule","normalizedDomains","extractDomainFrom","Dot","floor","random","endsWith","sourceMapFileNameParts","sourceMapFileNamePartsCount","lastPart","CommentsTransformer","CustomNodesTransformer","EvalCallExpressionTransformer","MetadataTransformer","ObfuscatingGuardsTransformer","ParentificationTransformer","INodeGuard","BlackListObfuscatingGuard","ReservedStringObfuscatingGuard","Factory__INodeGuard","VariablePreserveTransformer","blackListGuardsLength","blackListGuards","isUseStrictOperator","Initializing","rootNode","transformComments","commentIdx","findIndex","reverse","preservedWords","preservedWord","isConditionalComment","callsGraphAnalyzer","obfuscationEventEmitter","customNodeGroupStorage","Preparing","appendCustomNodesBeforeObfuscation","appendCustomNodesAfterObfuscation","customNodeGroup","once","getAppendEvent","appendCustomNodes","emit","TCustomNodeGroupStorage","evalRootAstHostNodeSet","extractEvalStringFromLiteralNode","extractEvalStringFromTemplateLiteralNode","isEvalRootAstHostNode","callExpressionFirstArgument","evalString","extractEvalStringFromCallExpressionArgument","ast","evalRootAstHostNode","targetAst","convertStructureToCode","obfuscatingGuardFactory","obfuscatingGuards","obfuscatingGuardsList","nodeGuard","check","isReservedString","reservedString","parentNodeIsPropertyNode","parentNodeIsMemberExpressionNode","parentNodeIsMethodDefinitionNode","CustomNodeGroupStorage","StringArrayStorage","Newable__TControlFlowStorage","ControlFlowStorage","customNodeGroupFactory","customNodeGroupsList","customNodeGroupName","rotationAmount","rc4Keys","rc4KeyLength","rc4KeysCount","baseStringArrayName","stringArrayNameLength","baseStringArrayCallsWrapperName","stringArrayStorageName","minimumRotationAmount","maximumRotationAmount","getOrSetIfDoesNotExist","rotate","entries","sort","stringArrayStorageItemDataA","stringArrayStorageItemDataB","encodedValue","getEncodedValue","storedStringArrayStorageItemData","btoa","rc4","ArrayUtils","CryptUtils","EscapeSequenceEncoder","ILevelledTopologicalSorter","LevelledTopologicalSorter","INodeTransformerNamesGroupsBuilder","NodeTransformerNamesGroupsBuilder","array","elementsMap","mostOccurringElement","mostOccurringElementCount","element","updatedElementCount","times","newArray","temp","shuffledArray","j","output","encodeURIComponent","match","p1","fromCharCode","parseInt","charCode","idx","charCodeAt","str","randomStringDiff","randomStringDiffArray","s1","s2","i1","i2","randomMerge","x","y","stringsCache","encodeAllSymbols","replaceRegExp","escapeSequenceRegExp","regExp","graph","precedent","link","register","consequents","results","marks","visit","resultItemsGroups","hasNodes","rootNodes","findRootNodes","delete","getPrecedents","precedentsGroups","precedentsGroup","hasPrecedents","precedents","mark","levelledTopologicalSorter","normalizedNodeTransformers","nodeTransformerNames","relationEdges","buildNodeTransformersRelationEdges","sortByGroups","nodeTransformerName","runAfterRelations","runAfterRelation","obfuscatedCodeFactory","logger","timeStart","Date","now","info","LoggingMessage","Version","ObfuscationStarted","RandomGeneratorSeed","parseCode","obfuscatedAstTree","transformAstTree","generatorOutput","generateCode","obfuscationTime","success","ObfuscationCompleted","parseOptions","runTransformationStage","warn","EmptySourceCode","escodegenParams","sourceContent","transformersList","allowHashBang","allowImportExportEverywhere","allowReturnOutsideFunction","locations","ranges","verbatim","decorate","correctObfuscatedCode","sourceMapUrl","sourceMappingUrl","nodeTransformerFactory","nodeTransformerNamesGroupsBuilder","cachedNodeTransformersData","nodeTransformerNamesGroups","buildNormalizedNodeTransformers","build","nodeTransformerNamesGroup","enterVisitors","leaveVisitors","visitor","getVisitor","mergeVisitorsForDirection","VisitorDirection","Enter","Leave","acc","visitors","direction","visitorsLength","visitorFunction","visitorResult","isNode","JavaScriptObfuscatorCLI","argv","rawArguments","filteredOptions","option","outputCodePath","CLIUtils","writeFile","outputSourceMapPath","getOutputSourceMapPath","path","basename","getSourceMap","inputPath","commands","commander","Command","configureCommands","configureHelp","inputCLIOptions","opts","outputHelp","sourceCodeData","SourceCodeReader","readSourceCode","processSourceCodeData","filterOptions","configFilePath","configFileLocation","resolve","configFileOptions","getUserConfig","usage","BooleanSanitizer","parseFloat","ArraySanitizer","IdentifierNamesGeneratorSanitizer","SourceMapModeSanitizer","StringArrayEncodingSanitizer","ObfuscationTargetSanitizer","on","outputPath","filePath","getOutputCodePath","processSourceCode","sourceCodeIndex","buildOptions","baseIdentifiersPrefix","processSourceCodeWithSourceMap","processSourceCodeWithoutSourceMap","encoding","obfuscatedFilePrefix","javaScriptObfuscatorCLI","run","SyntaxError","trim","lastIndexOf","configPath","data","mkdirp","sync","dirname","fs","writeFileSync","webpackEmptyContext","req","e","excludePatterns","fileName","isExcludedFilePathByGlobPattern","excludePattern","statSync","isDirectory","isFile","normalizedFilePath","CLI","isFilePath","isValidFile","readFile","isDirectoryPath","isValidDirectory","readDirectoryRecursive","availableFilePaths","availableInputExtensions","extension","directoryPath","fileData","readdirSync","logFilePath","readFileSync","isExcludedPath","extname"],"mappings":"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","file":"index.cli.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 202);\n","module.exports = require(\"inversify\");","module.exports = require(\"tslib\");","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscatedCode = 'Factory<IObfuscatedCode>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__IObjectExpressionKeysTransformerCustomNode = 'Factory<IObjectExpressionKeysTransformerCustomNode>',\n    Factory__IPropertiesExtractor = 'Factory<IPropertiesExtractor>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICallsGraphAnalyzer = 'ICallsGraphAnalyzer',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    ICustomNodeFormatter = 'ICustomNodeFormatter',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILevelledTopologicalSorter = 'ILevelledTopologicalSorter',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    INodeTransformerNamesGroupsBuilder = 'INodeTransformerNamesGroupsBuilder',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscatedCode = 'IObfuscatedCode',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IPrevailingKindOfVariablesAnalyzer = 'IPrevailingKindOfVariablesAnalyzer',\n    IPropertiesExtractor = 'IPropertiesExtractor',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    IScopeAnalyzer = 'IScopeAnalyzer',\n    IStringArrayStorageAnalyzer = 'IStringArrayStorageAnalyzer',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithLexicalStatements: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentExpressionNode (node: ESTree.Node): node is ESTree.AssignmentExpression {\n        return node.type === NodeType.AssignmentExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (\n        node: ESTree.Node\n    ): node is ESTree.ClassDeclaration & { id: ESTree.Identifier } {\n        return node.type === NodeType.ClassDeclaration && node.id !== null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isDirectiveNode (node: ESTree.Node): node is ESTree.Directive {\n        return node.type === NodeType.ExpressionStatement\n            && 'directive' in node;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExportNamedDeclarationNode (node: ESTree.Node): node is ESTree.ExportNamedDeclaration {\n        return node.type === NodeType.ExportNamedDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement\n            && !('directive' in node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForStatementTypeNode (\n        node: ESTree.Node\n    ): node is ESTree.ForStatement | ESTree.ForInStatement | ESTree.ForOfStatement {\n        return NodeGuards.isForStatementNode(node)\n            || NodeGuards.isForInStatementNode(node)\n            || NodeGuards.isForOfStatementNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForStatementNode (node: ESTree.Node): node is ESTree.ForStatement {\n        return node.type === NodeType.ForStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForInStatementNode (node: ESTree.Node): node is ESTree.ForInStatement {\n        return node.type === NodeType.ForInStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isForOfStatementNode (node: ESTree.Node): node is ESTree.ForOfStatement {\n        return node.type === NodeType.ForOfStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionNode (node: ESTree.Node): node is ESTree.Function {\n        return NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (\n        node: ESTree.Node\n    ): node is ESTree.FunctionDeclaration & { id: ESTree.Identifier } {\n        return node.type === NodeType.FunctionDeclaration && node.id !== null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIfStatementNode (node: ESTree.Node): node is ESTree.IfStatement {\n        return node.type === NodeType.IfStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDeclarationNode (node: ESTree.Node): node is ESTree.ImportDeclaration {\n        return node.type === NodeType.ImportDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportSpecifierNode (node: ESTree.Node): node is ESTree.ImportSpecifier {\n        return node.type === NodeType.ImportSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isProgramNode(node) || NodeGuards.isFunctionNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithBlockLexicalScope (node: ESTree.Node): node is TNodeWithLexicalScope {\n        return NodeGuards.isNodeWithLexicalScope(node) || NodeGuards.isBlockStatementNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeWithLexicalScopeStatements (\n        node: ESTree.Node,\n        parentNode: ESTree.Node\n    ): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || (NodeGuards.isBlockStatementNode(node) && NodeGuards.nodesWithLexicalStatements.includes(parentNode.type));\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithStatements (node: ESTree.Node): node is TNodeWithStatements {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsPropertyNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isPropertyNode(parentNode)\n            && !parentNode.computed\n            && parentNode.key === node;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsMemberExpressionNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return (\n            NodeGuards.isMemberExpressionNode(parentNode)\n            && !parentNode.computed\n            && parentNode.property === node\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static parentNodeIsMethodDefinitionNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isMethodDefinitionNode(parentNode)\n            && !parentNode.computed;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTaggedTemplateExpressionNode (node: ESTree.Node): node is ESTree.TaggedTemplateExpression {\n        return node.type === NodeType.TaggedTemplateExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.Directive {\n        return NodeGuards.isDirectiveNode(node)\n            && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: IInitializable[keyof IInitializable] = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): typeof originalMethod {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: typeof originalMethod = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey.toString()}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey.toString()}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n","import * as escodegen from 'escodegen';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ASTParserFacade } from '../ASTParserFacade';\nimport { NodeGuards } from './NodeGuards';\nimport { NodeMetadata } from './NodeMetadata';\n\nexport class NodeUtils {\n    /**\n     * @param {T} literalNode\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyTo (literalNode: ESTree.Literal): ESTree.Literal {\n        literalNode['x-verbatim-property'] = {\n            content: literalNode.raw,\n            precedence: escodegen.Precedence.Primary\n        };\n\n        return literalNode;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentizeAst(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {Statement[]}\n     */\n    public static convertCodeToStructure (code: string): ESTree.Statement[] {\n        const structure: ESTree.Program = ASTParserFacade.parse(code, {\n            ecmaVersion: 10,\n            sourceType: 'script'\n        });\n\n        estraverse.replace(structure, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node => {\n                NodeUtils.parentizeNode(node, parentNode);\n\n                if (NodeGuards.isLiteralNode(node)) {\n                    NodeUtils.addXVerbatimPropertyTo(node);\n                }\n\n                NodeMetadata.set(node, { ignoredNode: false });\n\n                return node;\n            }\n        });\n\n        return <ESTree.Statement[]>structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentizeAst <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: Partial<T> = {};\n        const nodeKeys: (keyof T)[] = <(keyof T)[]>Object.keys(node);\n\n        nodeKeys\n            .forEach((property: keyof T) => {\n                if (property === 'parentNode') {\n                    return;\n                }\n\n                const value: T[keyof T] = node[property];\n\n                let clonedValue: T[keyof T] | T[keyof T][] | null;\n\n                if (value === null || value instanceof RegExp) {\n                    clonedValue = value;\n                } else if (Array.isArray(value)) {\n                    clonedValue = value.map(NodeUtils.cloneRecursive);\n                } else if (typeof value === 'object') {\n                    clonedValue = NodeUtils.cloneRecursive(value);\n                } else {\n                    clonedValue = value;\n                }\n\n                copy[property] = <T[keyof T]>clonedValue;\n            });\n\n        return <T>copy;\n    }\n}\n","/* tslint:disable:max-file-line-count */\n\nimport * as escodegen from 'escodegen';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeFactory {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static programNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static arrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static assignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static binaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static blockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static breakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        return {\n            type: NodeType.BreakStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static callExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static continueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        return {\n            type: NodeType.ContinueStatement,\n            label,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Literal} expression\n     * @param {string} directive\n     * @returns {Directive}\n     */\n    public static directiveNode (\n        expression: ESTree.Literal,\n        directive: string\n    ): ESTree.Directive {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            directive,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static expressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static functionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: NodeFactory.identifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static functionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static ifStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static identifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static literalNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static logicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static memberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static methodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static objectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static propertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static returnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static switchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static switchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static unaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static updateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static variableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static variableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static whileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode <\n    TInitialData extends any[] = any[]\n> implements ICustomNode <TInitialData> {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ICustomNodeFormatter}\n     */\n    protected readonly customNodeFormatter: ICustomNodeFormatter;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    protected constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.customNodeFormatter = customNodeFormatter;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TInitialData} args\n     */\n    public abstract initialize (...args: TInitialData): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            const nodeTemplate: string = this.getNodeTemplate();\n\n            this.cachedNode = this.customNodeFormatter.formatStructure(\n                this.getNodeStructure(nodeTemplate)\n            );\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (nodeTemplate: string): TStatement[];\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return '';\n    }\n}\n","export enum TransformationStage {\n    Initializing = 'Initializing',\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer {\n    /**\n     * @type {NodeTransformer[] | undefined}\n     */\n    public readonly runAfter: NodeTransformer[] | undefined;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n","module.exports = require(\"estraverse\");","import * as ESTree from 'estree';\n\nexport class NodeMetadata {\n    /**\n     * @param {T} node\n     * @param {Partial<T[\"metadata\"]>} metadata\n     */\n    public static set <T extends ESTree.Node = ESTree.Node> (node: T, metadata: Partial<T['metadata']>): void {\n        node.metadata = Object.assign(node.metadata || {}, metadata);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {keyof T} metadataKey\n     * @returns {T[keyof T] | undefined}\n     */\n    public static get <T extends ESTree.BaseNodeMetadata> (node: ESTree.Node, metadataKey: keyof T): T[keyof T] | undefined {\n        return node.metadata !== undefined\n            ? (<T>node.metadata)[metadataKey]\n            : undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIgnoredNode (node: ESTree.Node): boolean {\n        return NodeMetadata.get(node, 'ignoredNode') === true;\n    }\n\n    /**\n     * @param {Node} literalNode\n     * @returns {boolean}\n     */\n    public static isReplacedLiteral (literalNode: ESTree.Literal): boolean {\n        return NodeMetadata.get<ESTree.LiteralNodeMetadata>(literalNode, 'replacedLiteral') === true;\n    }\n}\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const ObfuscationTarget: Readonly<{\n    Browser: 'browser';\n    BrowserNoEval: 'browser-no-eval';\n    Node: 'node';\n}> = MakeEnum({\n    Browser: 'browser',\n    BrowserNoEval: 'browser-no-eval',\n    Node: 'node'\n});\n","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscatedCode } from '../source-code/ObfuscatedCode';\nimport { SourceCode } from '../source-code/SourceCode';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, sourceMap: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode, sourceMap))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode)\n            .to(ObfuscatedCode);\n\n        this.container\n            .bind<IObfuscatedCode>(ServiceIdentifiers.Factory__IObfuscatedCode)\n            .toFactory<IObfuscatedCode>((context: interfaces.Context) => {\n                return (obfuscatedCodeAsString: string, sourceMapAsString: string) => {\n                    const obfuscatedCode: IObfuscatedCode = context.container\n                        .get<IObfuscatedCode>(ServiceIdentifiers.IObfuscatedCode);\n\n                    obfuscatedCode.initialize(obfuscatedCodeAsString, sourceMapAsString);\n\n                    return obfuscatedCode;\n                };\n            });\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICallsGraphData } from '../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static append (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n            ...statements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {ICallsGraphData[]} callsGraphData\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} bodyStatements\n     * @param {number} index\n     */\n    public static appendToOptimalBlockScope (\n        callsGraphData: ICallsGraphData[],\n        nodeWithStatements: TNodeWithStatements,\n        bodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        const targetBlockScope: TNodeWithStatements = callsGraphData.length\n            ? NodeAppender.getOptimalBlockScope(callsGraphData, index)\n            : nodeWithStatements;\n\n        NodeAppender.prepend(targetBlockScope, bodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {ICallsGraphData[]} callsGraphData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        callsGraphData: ICallsGraphData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: ICallsGraphData = callsGraphData[index];\n\n        if (deep <= 0) {\n            throw new Error('Invalid `deep` argument value. Value should be bigger then 0.');\n        }\n\n        if (deep > 1 && firstCall.callsGraph.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.callsGraph, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertBefore (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(nodeWithStatements)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(nodeWithStatements, statements, indexInScopeStatement);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertAfter (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(nodeWithStatements)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(nodeWithStatements, statements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @param {number} index\n     */\n    public static insertAtIndex (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[],\n        index: number\n    ): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(0, index),\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    public static prepend (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(nodeWithStatements, statements);\n\n        NodeAppender.setScopeStatements(nodeWithStatements, [\n            ...statements,\n            ...NodeAppender.getScopeStatements(nodeWithStatements),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @returns {TStatement[]}\n     */\n    private static getScopeStatements (nodeWithStatements: TNodeWithStatements): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            return nodeWithStatements.consequent;\n        }\n\n        return nodeWithStatements.body;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (\n        nodeWithStatements: TNodeWithStatements,\n        statements: TStatement[]\n    ): TStatement[] {\n        statements.forEach((statement: TStatement) => {\n            statement.parentNode = nodeWithStatements;\n        });\n\n        return statements;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {TStatement[]} statements\n     */\n    private static setScopeStatements (nodeWithStatements: TNodeWithStatements, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(nodeWithStatements)) {\n            nodeWithStatements.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        nodeWithStatements.body = statements;\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeStatementUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getParentNodeWithStatements (node: ESTree.Node): TNodeWithStatements {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithStatements[]}\n     */\n    public static getParentNodesWithStatements (node: ESTree.Node): TNodeWithStatements[] {\n        return NodeStatementUtils.getParentNodesWithStatementsRecursive(node);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, 1);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeStatementUtils.getSiblingStatementByOffset(statement, -1);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {Statement}\n     */\n    public static getRootStatementOfNode (node: ESTree.Node): ESTree.Statement {\n        if (NodeGuards.isProgramNode(node)) {\n            throw new Error('Unable to find root statement for `Program` node');\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getRootStatementOfNode(parentNode);\n        }\n\n        return <ESTree.Statement>node;\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithStatements}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithStatements {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeWithStatements(parentNode)) {\n            return NodeStatementUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithStatements[]} nodesWithStatements\n     * @param {number} depth\n     * @returns {TNodeWithStatements[]}\n     */\n    private static getParentNodesWithStatementsRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithStatements: TNodeWithStatements[] = [],\n        depth: number = 0\n    ): TNodeWithStatements[] {\n        if (nodesWithStatements.length >= maxSize) {\n            return nodesWithStatements;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            (NodeGuards.isNodeWithLexicalScopeStatements(node, parentNode) && depth > 0)\n        ) {\n            nodesWithStatements.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeStatementUtils.getParentNodesWithStatementsRecursive(parentNode, maxSize, nodesWithStatements, ++depth);\n        }\n\n        return nodesWithStatements;\n    }\n\n    /**\n     * @param {Statement} statement\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementByOffset (statement: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(statement);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(statement);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MetadataTransformer = 'MetadataTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    ScopeIdentifiersTransformer = 'ScopeIdentifiersTransformer',\n    SplitStringTransformer = 'SplitStringTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariablePreserveTransformer = 'VariablePreserveTransformer'\n}\n","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const StringArrayEncoding: Readonly<{\n    Base64: 'base64';\n    Rc4: 'rc4';\n}> = MakeEnum({\n    Base64: 'base64',\n    Rc4: 'rc4'\n});\n","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @type {string | undefined}\n     */\n    public static version: string = process.env.VERSION || 'unknown';\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscatedCode}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscatedCode {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, '', inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscatedCode: IObfuscatedCode = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscatedCode;\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExportNamedDeclaration = 'ExportNamedDeclaration',\n    ExpressionStatement = 'ExpressionStatement',\n    ForStatement = 'ForStatement',\n    ForInStatement = 'ForInStatement',\n    ForOfStatement = 'ForOfStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    ImportDeclaration = 'ImportDeclaration',\n    ImportDefaultSpecifier = 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier = 'ImportNamespaceSpecifier',\n    ImportSpecifier = 'ImportSpecifier',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TaggedTemplateExpression = 'TaggedTemplateExpression',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithStatements } from '../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public abstract appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} callsGraphLength\n     * @returns {number}\n     */\n    protected getRandomCallsGraphIndex (callsGraphLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(callsGraphLength - 1)));\n    }\n}\n","export class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFrom (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n}\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const IdentifierNamesGenerator: Readonly<{\n    DictionaryIdentifierNamesGenerator: 'dictionary';\n    HexadecimalIdentifierNamesGenerator: 'hexadecimal';\n    MangledIdentifierNamesGenerator: 'mangled';\n}> = MakeEnum({\n    DictionaryIdentifierNamesGenerator: 'dictionary',\n    HexadecimalIdentifierNamesGenerator: 'hexadecimal',\n    MangledIdentifierNamesGenerator: 'mangled'\n});\n","import { MakeEnum } from '@gradecam/tsenum';\n\nexport const SourceMapMode: Readonly<{\n    Inline: 'inline';\n    Separate: 'separate';\n}> = MakeEnum({\n    Inline: 'inline',\n    Separate: 'separate'\n});\n","module.exports = require(\"@gradecam/tsenum\");","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    identifiersDictionary: [],\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    shuffleStringArray: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    splitStrings: false,\n    splitStringsChunkLength: 0,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","export class NumberUtils {\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static toHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeil (number: number): boolean {\n        return number % 1 === 0;\n    }\n}\n","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../../../types/node/TNodeWithLexicalScope';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, lexicalScopeNode?: TNodeWithLexicalScope): ESTree.Node;\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: TControlFlowStorage): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: TControlFlowStorage,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n","module.exports = require(\"escodegen\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport abstract class AbstractPropertiesExtractor implements IPropertiesExtractor {\n    /**\n     * @type {Map<ESTree.ObjectExpression, TNodeWithStatements>}\n     */\n    protected readonly cachedHostNodesWithStatementsMap: Map <ESTree.ObjectExpression, TNodeWithStatements> = new Map();\n\n    /**\n     * @type {Map<ESTree.ObjectExpression, ESTree.Statement>}\n     */\n    protected readonly cachedHostStatementsMap: Map <ESTree.ObjectExpression, ESTree.Statement> = new Map();\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    protected static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        if (!propertyNode.key) {\n            return null;\n        }\n\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (\n            NodeGuards.isLiteralNode(propertyKeyNode)\n            && (\n                typeof propertyKeyNode.value === 'string'\n                || typeof propertyKeyNode.value === 'number'\n            )\n        ) {\n            return propertyKeyNode.value.toString();\n        }\n\n        if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedPattern (node: ESTree.Node): node is ESTree.Pattern {\n        return !node\n            || NodeGuards.isObjectPatternNode(node)\n            || NodeGuards.isArrayPatternNode(node)\n            || NodeGuards.isAssignmentPatternNode(node)\n            || NodeGuards.isRestElementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} hostNode\n     * @returns {Node}\n     */\n    public abstract extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.Node\n    ): ESTree.Node;\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionHostNode\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    protected extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionHostNode: ESTree.Expression\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (AbstractPropertiesExtractor.isProhibitedPattern(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = AbstractPropertiesExtractor.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && !!property.key && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? NodeFactory.literalNode(propertyKeyName)\n                : NodeFactory.identifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = NodeFactory\n                .memberExpressionNode(memberExpressionHostNode, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = NodeFactory.expressionStatementNode(\n                NodeFactory.assignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {number[]} removablePropertyIds\n     */\n    protected filterExtractedObjectExpressionProperties (\n        objectExpressionNode: ESTree.ObjectExpression,\n        removablePropertyIds: number[]\n    ): void {\n        objectExpressionNode.properties = objectExpressionNode.properties\n            .filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionHostNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Expression\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionHostNode);\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const hostNodeWithStatements: TNodeWithStatements = this.getHostNodeWithStatements(\n            objectExpressionNode,\n            hostStatement\n        );\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertAfter(hostNodeWithStatements, expressionStatements, hostStatement);\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Statement} hostStatement\n     * @returns {TNodeWithStatements}\n     */\n    protected getHostNodeWithStatements (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostStatement: ESTree.Statement\n    ): TNodeWithStatements {\n        if (this.cachedHostNodesWithStatementsMap.has(objectExpressionNode)) {\n            return <TNodeWithStatements>this.cachedHostNodesWithStatementsMap.get(objectExpressionNode);\n        }\n\n        const nodeWithStatements: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(hostStatement);\n\n        this.cachedHostNodesWithStatementsMap.set(objectExpressionNode, nodeWithStatements);\n\n        return nodeWithStatements;\n    }\n\n    /**\n     * Returns host statement of object expression node\n     *\n     * @param {NodeGuards} objectExpressionNode\n     * @returns {Node}\n     */\n    protected getHostStatement (objectExpressionNode: ESTree.ObjectExpression): ESTree.Statement {\n        if (this.cachedHostStatementsMap.has(objectExpressionNode)) {\n            return <ESTree.Statement>this.cachedHostStatementsMap.get(objectExpressionNode);\n        }\n\n        const hostStatement: ESTree.Statement = NodeStatementUtils.getRootStatementOfNode(objectExpressionNode);\n\n        this.cachedHostStatementsMap.set(objectExpressionNode, hostStatement);\n\n        return hostStatement;\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        const that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Array}\n     */\n    protected readonly preservedNames: string[] = [];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generate (nameLength?: number): string;\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (nameLength?: number): string;\n\n    /**\n     * @param {string} name\n     * @returns {void}\n     */\n    public preserveName (name: string): void {\n        this.preservedNames.push(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (name: string): boolean {\n        return this.notReservedName(name) && !this.preservedNames.includes(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private notReservedName (name: string): boolean {\n        return this.options.reservedNames.length\n            ? !this.options.reservedNames.some((reservedName: string) =>\n                new RegExp(reservedName, 'g').exec(name) !== null\n            )\n            : true;\n\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IMapStorage } from '../interfaces/storages/IMapStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <K, V> implements IMapStorage <K, V> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <K, V>}\n     */\n    @initializable()\n    protected storage!: Map <K, V>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <K, V>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V | undefined}\n     */\n    public get (key: K): V | undefined {\n        return this.storage.get(key);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V}\n     */\n    public getOrThrow (key: K): V {\n        const value: V | undefined = this.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {K | null}\n     */\n    public getKeyOf (value: V): K | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map<K, V>}\n     */\n    public getStorage (): Map <K, V> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {K} key\n     * @returns {boolean}\n     */\n    public has (key: K): boolean {\n        return this.storage.has(key);\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <K, V>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    public set (key: K, value: V): void {\n        this.storage.set(key, value);\n    }\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    identifiersDictionary: [],\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    reservedStrings: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    shuffleStringArray: true,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    splitStrings: false,\n    splitStringsChunkLength: 10,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","export enum StringSeparator {\n    Dot = '.'\n}\n","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode<TInitialData<ExpressionWithOperatorControlFlowStorageCallNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import * as acorn from 'acorn';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over AST parser `acorn`\n */\nexport class ASTParserFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 15;\n\n    /**\n     * @type {acorn.Options['sourceType'][]}\n     */\n    private static readonly sourceTypes: acorn.Options['sourceType'][] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @param {string} input\n     * @param {Options} config\n     * @returns {Program}\n     */\n    public static parse (input: string, config: acorn.Options): ESTree.Program | never {\n        const sourceTypeLength: number = ASTParserFacade.sourceTypes.length;\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                return ASTParserFacade.parseType(input, config, ASTParserFacade.sourceTypes[i]);\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(ASTParserFacade.processParsingError(\n                    input,\n                    error.message,\n                    error.loc\n                ));\n            }\n        }\n\n        throw new Error(`Acorn parsing error`);\n    }\n\n    /**\n     * @param {string} input\n     * @param {acorn.Options} inputConfig\n     * @param {acorn.Options[\"sourceType\"]} sourceType\n     * @returns {Program}\n     */\n    private static parseType (\n        input: string,\n        inputConfig: acorn.Options,\n        sourceType: acorn.Options['sourceType']\n    ): ESTree.Program {\n        const comments: ESTree.Comment[] = [];\n        const config: acorn.Options = {\n            ...inputConfig,\n            onComment: comments,\n            sourceType\n        };\n\n        const program: ESTree.Program = <any>acorn.parse(input, config);\n\n        if (comments.length) {\n            program.comments = comments;\n        }\n\n        return program;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {Position} position\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, position: ESTree.Position | null): never {\n        if (!position || !position.line || !position.column) {\n            throw new Error(errorMessage);\n        }\n\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[position.line - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, position.column - ASTParserFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, position.column + ASTParserFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = ASTParserFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`Line ${position.line}: ${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n","module.exports = require(\"chalk\");","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n","export enum PropertiesExtractor {\n    AssignmentExpressionPropertiesExtractor = 'AssignmentExpressionPropertiesExtractor',\n    BasePropertiesExtractor = 'BasePropertiesExtractor',\n    VariableDeclaratorPropertiesExtractor = 'VariableDeclaratorPropertiesExtractor'\n}\n","export enum ObjectExpressionKeysTransformerCustomNode {\n    BasePropertiesExtractorObjectExpressionHostNode =\n        'BasePropertiesExtractorObjectExpressionHostNode'\n}\n","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n","export enum ObfuscatingGuard {\n    BlackListObfuscatingGuard = 'BlackListObfuscatingGuard',\n    ConditionalCommentObfuscatingGuard = 'ConditionalCommentObfuscatingGuard',\n    ReservedStringObfuscatingGuard = 'ReservedStringObfuscatingGuard'\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @param {Comment} comment\n     * @returns {boolean}\n     */\n    public static isConditionalComment (comment: ESTree.Comment): boolean {\n        return ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value) ||\n            ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value);\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.randomGenerator = new Chance(this.getRawSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getInputSeed (): string {\n        return this.options.seed.toString();\n    }\n\n    /**\n     * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n     * for different bundles with same seed\n     *\n     * @returns {number}\n     */\n    public getRawSeed (): string {\n        const inputSeed: string = this.getInputSeed();\n        const inputSeedParts: string[] = `${inputSeed}`.split('|');\n\n        if (inputSeedParts.length > 1) {\n            return inputSeed;\n        }\n\n        const sourceCodeMD5Hash: string = md5(this.sourceCode.getSourceCode());\n\n        return `${inputSeed}|${sourceCodeMD5Hash}`;\n    }\n}\n","module.exports = require(\"reflect-metadata\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\nimport { LoggingPrefix } from '../enums/logger/LoggingPrefix';\n\n@injectable()\nexport class Logger implements ILogger {\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorInfo: Chalk = chalk.cyan;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorSuccess: Chalk = chalk.green;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorWarn: Chalk = chalk.yellow;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingPrefix} loggingPrefix\n     * @param {string} loggingMessage\n     * @param {string | number} value\n     */\n    public static log (\n        loggingLevelColor: Chalk,\n        loggingPrefix: LoggingPrefix,\n        loggingMessage: string,\n        value?: string | number,\n    ): void {\n        const processedMessage: string = loggingLevelColor(`\\n${loggingPrefix} ${loggingMessage}`);\n\n        console.log(processedMessage, value || '');\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorInfo, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorSuccess, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorWarn, LoggingPrefix.Base, loggingMessage, value);\n    }\n}\n","export enum LoggingPrefix {\n    Base = '[javascript-obfuscator]',\n    CLI = '[javascript-obfuscator-cli]'\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeDataExtractor';\nimport { ICallsGraphAnalyzer } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphAnalyzer';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../../../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\nimport { IScopeAnalyzer } from '../../../interfaces/analyzers/scope-analyzer/IScopeAnalyzer';\nimport { IStringArrayStorageAnalyzer } from '../../../interfaces/analyzers/string-array-storage-analyzer/IStringArrayStorageAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/calls-graph-analyzer/CalleeDataExtractor';\nimport { CallsGraphAnalyzer } from '../../../analyzers/calls-graph-analyzer/CallsGraphAnalyzer';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/calls-graph-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/calls-graph-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/calls-graph-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { PrevailingKindOfVariablesAnalyzer } from '../../../analyzers/prevailing-kind-of-variables-analyzer/PrevailingKindOfVariablesAnalyzer';\nimport { ScopeAnalyzer } from '../../../analyzers/scope-analyzer/ScopeAnalyzer';\nimport { StringArrayStorageAnalyzer } from '../../../analyzers/string-array-storage-analyzer/StringArrayStorageAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // calls graph analyzer\n    bind<ICallsGraphAnalyzer>(ServiceIdentifiers.ICallsGraphAnalyzer)\n        .to(CallsGraphAnalyzer)\n        .inSingletonScope();\n\n    // prevailing kind of variables analyzer\n    bind<IPrevailingKindOfVariablesAnalyzer>(ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)\n        .to(PrevailingKindOfVariablesAnalyzer)\n        .inSingletonScope();\n\n    // scope analyzer\n    bind<IScopeAnalyzer>(ServiceIdentifiers.IScopeAnalyzer)\n        .to(ScopeAnalyzer)\n        .inSingletonScope();\n\n    // string array storage analyzer\n    bind<IStringArrayStorageAnalyzer>(ServiceIdentifiers.IStringArrayStorageAnalyzer)\n        .to(StringArrayStorageAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // callee data extractor factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/calls-graph-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\nimport { ICallsGraphAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphAnalyzer';\nimport { ICallsGraphData } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/calls-graph-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\n\n/**\n * This class generates a data with a graph of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class CallsGraphAnalyzer implements ICallsGraphAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = CallsGraphAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * CallsGraphAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {ICallsGraphData[]}\n     */\n    public analyze (astTree: ESTree.Program): ICallsGraphData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {ICallsGraphData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): ICallsGraphData[] {\n        const limitIndex: number = CallsGraphAnalyzer.getLimitIndex(blockScopeBody.length);\n        const callsGraphData: ICallsGraphData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeStatementUtils.getParentNodeWithStatements(node)) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(callsGraphData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return callsGraphData;\n    }\n\n    /**\n     * @param {ICallsGraphData[]} callsGraphData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        callsGraphData: ICallsGraphData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        CallsGraphAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            callsGraphData.push({\n                ...calleeData,\n                callsGraph: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/calls-graph-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../../node/NodeStatementUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {Property} propertyNode\n     * @param {string | number} nextItemInCallsChain\n     * @returns {boolean}\n     */\n    private static isValidTargetPropertyNode (propertyNode: ESTree.Property, nextItemInCallsChain: string | number): boolean {\n        if (!propertyNode.key) {\n            return false;\n        }\n\n        const isTargetPropertyNodeWithIdentifierKey: boolean =\n            NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n        const isTargetPropertyNodeWithLiteralKey: boolean =\n            NodeGuards.isLiteralNode(propertyNode.key) &&\n            Boolean(propertyNode.key.value) &&\n            propertyNode.key.value === nextItemInCallsChain;\n\n        return isTargetPropertyNodeWithIdentifierKey || isTargetPropertyNodeWithLiteralKey;\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeStatementUtils.getParentNodeWithStatements(blockScopeBody[0]),\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            if (!ObjectExpressionCalleeDataExtractor.isValidTargetPropertyNode(propertyNode, nextItemInCallsChain)) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\n\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class PrevailingKindOfVariablesAnalyzer implements IPrevailingKindOfVariablesAnalyzer {\n    /**\n     * @type {ESTree.VariableDeclaration['kind']}\n     */\n    private static readonly defaultKindOfVariables: ESTree.VariableDeclaration['kind'] = 'var';\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {ESTree.VariableDeclaration['kind']}\n     */\n    private prevailingKindOfVariables: ESTree.VariableDeclaration['kind'] = PrevailingKindOfVariablesAnalyzer.defaultKindOfVariables;\n\n    constructor (\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils\n    ) {\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {Program} astTree\n     */\n    public analyze (astTree: ESTree.Program): void {\n        const variableKinds: ESTree.VariableDeclaration['kind'][] = [];\n\n        estraverse.traverse(astTree, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (!NodeGuards.isVariableDeclarationNode(node)) {\n                    return;\n                }\n\n                variableKinds.push(node.kind);\n            }\n        });\n\n        this.prevailingKindOfVariables = this.arrayUtils.findMostOccurringElement(variableKinds)\n            || PrevailingKindOfVariablesAnalyzer.defaultKindOfVariables;\n    }\n\n    /**\n     * @returns {VariableDeclaration[\"kind\"]}\n     */\n    public getPrevailingKind (): ESTree.VariableDeclaration['kind'] {\n        return this.prevailingKindOfVariables;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as eslintScope from 'eslint-scope';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IScopeAnalyzer } from '../../interfaces/analyzers/scope-analyzer/IScopeAnalyzer';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class ScopeAnalyzer implements IScopeAnalyzer {\n    /**\n     * @type {eslintScope.AnalysisOptions}\n     */\n    private static readonly eslintScopeOptions: eslintScope.AnalysisOptions = {\n        ecmaVersion: 10,\n        optimistic: true\n    };\n\n    /**\n     * @type {acorn.Options['sourceType'][]}\n     */\n    private static readonly sourceTypes: acorn.Options['sourceType'][] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {eslintScope.ScopeManager | null}\n     */\n    private scopeManager: eslintScope.ScopeManager | null = null;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * `eslint-scope` reads `ranges` property of a nodes\n     * Should attach that property to the some custom nodes\n     *\n     * @param {Node} astTree\n     */\n    private static attachMissingRanges (astTree: ESTree.Node): void {\n        estraverse.replace(astTree, {\n            enter: (node: ESTree.Node): ESTree.Node => {\n                if (!node.range) {\n                    node.range = [0, 0];\n                }\n\n                return node;\n            }\n        });\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isRootNode (node: ESTree.Node): boolean {\n        return NodeGuards.isProgramNode(node) || node.parentNode === node;\n    }\n\n    /**\n     * @param {Program} astTree\n     */\n    public analyze (astTree: ESTree.Program): void {\n        const sourceTypeLength: number = ScopeAnalyzer.sourceTypes.length;\n\n        ScopeAnalyzer.attachMissingRanges(astTree);\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                this.scopeManager = eslintScope.analyze(astTree, {\n                    ...ScopeAnalyzer.eslintScopeOptions,\n                    nodejsScope: this.options.target === ObfuscationTarget.Node,\n                    sourceType: ScopeAnalyzer.sourceTypes[i]\n                });\n\n                return;\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(error);\n            }\n        }\n\n        throw new Error(`Scope analyzing error`);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {Scope}\n     */\n    public acquireScope (node: ESTree.Node): eslintScope.Scope {\n        if (!this.scopeManager) {\n            throw new Error('Scope manager is not defined');\n        }\n\n        const scope: eslintScope.Scope | null = this.scopeManager.acquire(\n            node,\n            ScopeAnalyzer.isRootNode(node)\n        );\n\n        if (!scope) {\n            throw new Error('Cannot acquire scope for node');\n        }\n\n        return scope;\n    }\n}\n","module.exports = require(\"eslint-scope\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayStorage } from '../../interfaces/storages/string-array-storage/IStringArrayStorage';\nimport { IStringArrayStorageAnalyzer } from '../../interfaces/analyzers/string-array-storage-analyzer/IStringArrayStorageAnalyzer';\nimport { IStringArrayStorageItemData } from '../../interfaces/storages/string-array-storage/IStringArrayStorageItem';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds values of literal nodes to the string array storage\n */\n@injectable()\nexport class StringArrayStorageAnalyzer implements IStringArrayStorageAnalyzer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {randomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IStringArrayStorage}\n     */\n    private readonly stringArrayStorage: IStringArrayStorage;\n\n    /**\n     * @type {Map<ESTree.Literal, IStringArrayStorageItemData>}\n     */\n    private readonly stringArrayStorageData: Map<ESTree.Literal, IStringArrayStorageItemData> = new Map();\n\n    /**\n     * @param {IStringArrayStorage} stringArrayStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: IStringArrayStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n    ) {\n        this.stringArrayStorage = stringArrayStorage;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Program} astTree\n     */\n    public analyze (astTree: ESTree.Program): void {\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        estraverse.traverse(astTree, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!NodeGuards.isLiteralNode(node)) {\n                    return;\n                }\n\n                this.analyzeLiteralNode(node);\n            }\n        });\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @returns {IStringArrayStorageItemData | undefined}\n     */\n    public getItemDataForLiteralNode (literalNode: ESTree.Literal): IStringArrayStorageItemData | undefined {\n        return this.stringArrayStorageData.get(literalNode);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     */\n    private analyzeLiteralNode (literalNode: ESTree.Literal): void {\n        if (typeof literalNode.value !== 'string') {\n            return;\n        }\n\n        if (!this.shouldAddValueToStringArray(literalNode.value)) {\n            return;\n        }\n\n        this.stringArrayStorageData.set(\n            literalNode,\n            this.stringArrayStorage.getOrThrow(literalNode.value)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {boolean}\n     */\n    private shouldAddValueToStringArray (value: string): boolean {\n        return value.length >= StringArrayStorageAnalyzer.minimumLengthForStringArray\n            && this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const operator: ESTree.BinaryOperator = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode<TInitialData<BinaryExpressionFunctionNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n        binaryExpressionFunctionCustomNode.initialize(operator);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            operator,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TInitialData } from '../../types/TInitialData';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { BlockStatementControlFlowFlatteningNode } from '../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedStatementNode (node: ESTree.Node): boolean {\n        const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(node)\n            || NodeGuards.isContinueStatementNode(node);\n        const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(node)\n            && (node.kind === 'const' || node.kind === 'let');\n        const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(node);\n\n        return NodeGuards.isFunctionDeclarationNode(node)\n            || isBreakOrContinueStatement\n            || isVariableDeclarationWithLetOrConstKind\n            || isClassDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (BlockStatementControlFlowTransformer.isProhibitedStatementNode(node)) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.createWithRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.shuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode<TInitialData<BlockStatementControlFlowFlatteningNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","module.exports = require(\"acorn\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode<TInitialData<CallExpressionFunctionNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.CallExpressionFunctionNode);\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode<TInitialData<CallExpressionControlFlowStorageCallNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TInitialData } from '../../types/TInitialData';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { BlockStatementDeadCodeInjectionNode } from '../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.ScopeIdentifiersTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TDeadNodeInjectionCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithStatements = NodeStatementUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = NodeFactory.blockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const parentNodeWithStatements: TNodeWithStatements = NodeStatementUtils\n            .getParentNodeWithStatements(blockStatementNode);\n\n        return parentNodeWithStatements.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                const clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                const transformedBlockStatementNode: ESTree.BlockStatement =\n                    this.makeClonedBlockStatementNodeUnique(clonedBlockStatementNode);\n\n                this.collectedBlockStatements.push(transformedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * Make all identifiers in cloned block statement unique\n     *\n     * @param {BlockStatement} clonedBlockStatementNode\n     * @returns {BlockStatement}\n     */\n    private makeClonedBlockStatementNodeUnique (clonedBlockStatementNode: ESTree.BlockStatement): ESTree.BlockStatement {\n        // should wrap cloned block statement node into function node for correct scope encapsulation\n        const hostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], clonedBlockStatementNode);\n\n        NodeUtils.parentizeNode(hostNode, hostNode);\n        NodeUtils.parentizeNode(clonedBlockStatementNode, hostNode);\n\n        return this.transformersRunner.transform(\n            hostNode,\n            DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n            TransformationStage.Obfuscating\n        ).body;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.functionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode<TInitialData<BlockStatementDeadCodeInjectionNode>> =\n            this.deadCodeInjectionCustomNodeFactory(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorage } from '../../types/storages/TControlFlowStorage';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TInitialData } from '../../types/TInitialData';\nimport { TNodeWithStatements } from '../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { ControlFlowStorageNode } from '../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeStatementUtils } from '../../node/NodeStatementUtils';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, TControlFlowStorage>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, TControlFlowStorage> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithStatements>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithStatements> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithStatements = this.getHostNode(functionNode.body);\n        const controlFlowStorage: TControlFlowStorage = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode<TInitialData<ControlFlowStorageNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.ControlFlowStorageNode);\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prepend(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        NodeUtils.parentizeAst(functionNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithStatements} hostNode\n     * @returns {TControlFlowStorage}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithStatements): TControlFlowStorage {\n        const controlFlowStorage: TControlFlowStorage = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                if (NodeGuards.isSwitchCaseNode(hostNode)) {\n                    hostNode.consequent.shift();\n                } else {\n                    hostNode.body.shift();\n                }\n            }\n\n            const hostControlFlowStorage: TControlFlowStorage = <TControlFlowStorage>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithStatements}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithStatements {\n        const blockScopesOfNode: TNodeWithStatements[] = NodeStatementUtils.getParentNodesWithStatements(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: TControlFlowStorage): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const operator: ESTree.LogicalOperator = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode<TInitialData<LogicalExpressionFunctionNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n        logicalExpressionFunctionCustomNode.initialize(operator);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            operator,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode<TInitialData<StringLiteralNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.StringLiteralNode);\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode<TInitialData<StringLiteralControlFlowStorageCallNode>> =\n            this.controlFlowCustomNodeFactory(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { PropertiesExtractor } from '../../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\n\nimport { AssignmentExpressionPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor';\nimport { BasePropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/BasePropertiesExtractor';\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionTransformer';\nimport { SplitStringTransformer } from '../../../node-transformers/converting-transformers/SplitStringTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\nimport { VariableDeclaratorPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(SplitStringTransformer)\n        .whenTargetNamed(NodeTransformer.SplitStringTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n\n    // properties extractors\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(AssignmentExpressionPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.AssignmentExpressionPropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(BasePropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.BasePropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(VariableDeclaratorPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.VariableDeclaratorPropertiesExtractor);\n\n    // properties extractor factory\n    bind<IPropertiesExtractor>(ServiceIdentifiers.Factory__IPropertiesExtractor)\n        .toFactory<IPropertiesExtractor>(InversifyContainerFacade\n            .getCacheFactory<PropertiesExtractor, IPropertiesExtractor>(\n                ServiceIdentifiers.IPropertiesExtractor\n            ));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class AssignmentExpressionPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    private static isProhibitedHostParent (node: ESTree.Node): node is ESTree.Pattern {\n        if (NodeGuards.isMemberExpressionNode(node)) {\n            return true;\n        }\n\n        if (AssignmentExpressionPropertiesExtractor.isProhibitedStatementNode(node)) {\n            return true;\n        }\n\n        // statements without block statement\n        return NodeGuards.isExpressionStatementNode(node)\n            && !!node.parentNode\n            && AssignmentExpressionPropertiesExtractor.isProhibitedStatementNode(node.parentNode);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private static isProhibitedStatementNode (node: ESTree.Node): boolean {\n        return NodeGuards.isIfStatementNode(node)\n            || NodeGuards.isForStatementTypeNode(node)\n            || NodeGuards.isWhileStatementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {AssignmentExpression} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.AssignmentExpression\n    ): ESTree.Node {\n        const hostParentNode: ESTree.Node | undefined = hostNode.parentNode;\n        const leftNode: ESTree.MemberExpression | ESTree.Pattern = hostNode.left;\n\n        // left node shouldn't be as Pattern node\n        if (AbstractPropertiesExtractor.isProhibitedPattern(leftNode)) {\n            return objectExpressionNode;\n        }\n\n        // left node shouldn't be as prohibited node\n        if (hostParentNode && AssignmentExpressionPropertiesExtractor.isProhibitedHostParent(hostParentNode)) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            leftNode\n        );\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\nimport { TObjectExpressionKeysTransformerCustomNodeFactory } from '../../../types/container/custom-nodes/TObjectExpressionKeysTransformerCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ObjectExpressionKeysTransformerCustomNode } from '../../../enums/custom-nodes/ObjectExpressionKeysTransformerCustomNode';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { BasePropertiesExtractorObjectExpressionHostNode } from '../../../custom-nodes/object-expression-keys-transformer-nodes/BasePropertiesExtractorObjectExpressionHostNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BasePropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @type {TObjectExpressionKeysTransformerCustomNodeFactory}\n     */\n    private readonly objectExpressionKeysTransformerCustomNodeFactory: TObjectExpressionKeysTransformerCustomNodeFactory;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {TObjectExpressionKeysTransformerCustomNodeFactory} objectExpressionKeysTransformerCustomNodeFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.Factory__IObjectExpressionKeysTransformerCustomNode)\n            objectExpressionKeysTransformerCustomNodeFactory: TObjectExpressionKeysTransformerCustomNodeFactory,\n    ) {\n        super(randomGenerator, options);\n\n        this.objectExpressionKeysTransformerCustomNodeFactory = objectExpressionKeysTransformerCustomNodeFactory;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        parentNode: ESTree.Node\n    ): ESTree.Node {\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            parentNode\n        );\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        parentNode: ESTree.Node\n    ): ESTree.Node {\n        const newObjectExpressionHostNode: ESTree.VariableDeclaration = this.getObjectExpressionHostNode();\n        const newObjectExpressionIdentifier: ESTree.Identifier = this.getObjectExpressionIdentifierNode(newObjectExpressionHostNode);\n\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, newObjectExpressionIdentifier);\n        const statementsToInsert: TStatement[] = [\n            newObjectExpressionHostNode,\n            ...expressionStatements\n        ];\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const hostNodeWithStatements: TNodeWithStatements = this.getHostNodeWithStatements(\n            objectExpressionNode,\n            hostStatement\n        );\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertBefore(hostNodeWithStatements, statementsToInsert, hostStatement);\n\n        return newObjectExpressionIdentifier;\n    }\n\n    /**\n     * @returns {VariableDeclaration}\n     */\n    private getObjectExpressionHostNode (): ESTree.VariableDeclaration {\n        const objectExpressionHostCustomNode: ICustomNode<TInitialData<BasePropertiesExtractorObjectExpressionHostNode>> =\n            this.objectExpressionKeysTransformerCustomNodeFactory(\n                ObjectExpressionKeysTransformerCustomNode.BasePropertiesExtractorObjectExpressionHostNode\n            );\n\n        objectExpressionHostCustomNode.initialize();\n\n        const statementNode: TStatement = objectExpressionHostCustomNode.getNode()[0];\n\n        if (\n            !statementNode\n            || !NodeGuards.isVariableDeclarationNode(statementNode)\n        ) {\n            throw new Error(`\\`objectExpressionHostCustomNode.getNode()[0]\\` should returns array with \\`VariableDeclaration\\` node`);\n        }\n\n        return statementNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} objectExpressionHostNode\n     * @returns {Identifier}\n     */\n    private getObjectExpressionIdentifierNode (objectExpressionHostNode: ESTree.VariableDeclaration): ESTree.Identifier {\n        const newObjectExpressionIdentifierNode: ESTree.Pattern = objectExpressionHostNode.declarations[0].id;\n\n        if (!NodeGuards.isIdentifierNode(newObjectExpressionIdentifierNode)) {\n            throw new Error(`\\`objectExpressionHostNode\\` should contain \\`VariableDeclarator\\` node with \\`Identifier\\` id property`);\n        }\n\n        return newObjectExpressionIdentifierNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = NodeFactory.literalNode(memberExpressionNode.property.name);\n        }\n\n        return memberExpressionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * or\n *     'foo' () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(methodDefinitionNode.key)) {\n            return this.replaceIdentifierKey(methodDefinitionNode, methodDefinitionNode.key);\n        }\n\n        if (NodeGuards.isLiteralNode(methodDefinitionNode.key)) {\n            return this.replaceLiteralKey(methodDefinitionNode, methodDefinitionNode.key);\n        }\n\n        return methodDefinitionNode;\n    }\n\n    /**\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {Identifier} keyNode\n     * @returns {MethodDefinition}\n     */\n    private replaceIdentifierKey (\n        methodDefinitionNode: ESTree.MethodDefinition,\n        keyNode: ESTree.Identifier\n    ): ESTree.MethodDefinition {\n        if (\n            !MethodDefinitionTransformer.ignoredNames.includes(keyNode.name)\n            && !methodDefinitionNode.computed\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = NodeFactory.literalNode(keyNode.name);\n        }\n\n        return methodDefinitionNode;\n    }\n\n    /**\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {Literal} keyNode\n     * @returns {MethodDefinition}\n     */\n    private replaceLiteralKey (\n        methodDefinitionNode: ESTree.MethodDefinition,\n        keyNode: ESTree.Literal\n    ): ESTree.MethodDefinition {\n        if (\n            typeof keyNode.value === 'string'\n            && !MethodDefinitionTransformer.ignoredNames.includes(keyNode.value)\n            && !methodDefinitionNode.computed\n        ) {\n            methodDefinitionNode.computed = true;\n        }\n\n        return methodDefinitionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TPropertiesExtractorFactory } from '../../types/container/node-transformers/TPropertiesExtractorFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { PropertiesExtractor } from '../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<string, PropertiesExtractor>}\n     */\n    private static readonly propertiesExtractorsMap: Map <string, PropertiesExtractor> = new Map([\n        [NodeType.AssignmentExpression, PropertiesExtractor.AssignmentExpressionPropertiesExtractor],\n        [NodeType.VariableDeclarator, PropertiesExtractor.VariableDeclaratorPropertiesExtractor]\n    ]);\n\n    /**\n     * @type {TPropertiesExtractorFactory}\n     */\n    private readonly propertiesExtractorFactory: TPropertiesExtractorFactory;\n\n    /**\n     * @param {TPropertiesExtractorFactory} propertiesExtractorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IPropertiesExtractor)\n            propertiesExtractorFactory: TPropertiesExtractorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.propertiesExtractorFactory = propertiesExtractorFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        if (!this.options.transformObjectKeys) {\n            return null;\n        }\n\n        if (transformationStage !== TransformationStage.Converting) {\n            return null;\n        }\n\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            },\n            leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNodeWithBaseExtractor(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractorName: PropertiesExtractor | undefined = ObjectExpressionKeysTransformer\n            .propertiesExtractorsMap\n            .get(parentNode.type);\n\n        if (!propertiesExtractorName) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(propertiesExtractorName);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n\n    /**\n     * replaces:\n     *     return {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *     return object;\n     *\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNodeWithBaseExtractor (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(PropertiesExtractor.BasePropertiesExtractor);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (!property.key) {\n                    return;\n                }\n\n                if (property.computed) {\n                    this.transformComputedProperty(property);\n                } else {\n                    this.transformBaseProperty(property);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformComputedProperty (property: ESTree.Property): void {\n        if (!NodeGuards.isLiteralNode(property.key) || !(typeof property.key.value === 'string')) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.value));\n    }\n\n    /**\n     * @param {Property} property\n     */\n    private transformBaseProperty (property: ESTree.Property): void {\n        if (property.shorthand) {\n            property.shorthand = false;\n        }\n\n        if (!NodeGuards.isIdentifierNode(property.key)) {\n            return;\n        }\n\n        property.key = NodeFactory.literalNode(this.getPropertyKeyValue(property.key.name));\n    }\n\n    /**\n     * @param {string} inputValue\n     * @returns {string}\n     */\n    private getPropertyKeyValue (inputValue: string): string {\n        return this.options.unicodeEscapeSequence\n            ? this.escapeSequenceEncoder.encode(inputValue, true)\n            : inputValue;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Splits strings into parts\n */\n@injectable()\nexport class SplitStringTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {NodeTransformer[]}\n     */\n    public runAfter: NodeTransformer[] = [\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.TemplateLiteralTransformer\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {string} string\n     * @param {number} chunkSize\n     * @returns {string[]}\n     */\n    private static chunkString (string: string, chunkSize: number): string[] {\n        const chunksCount: number = Math.ceil(string.length / chunkSize);\n        const chunks: string[] = [];\n\n        let nextChunkStartIndex: number = 0;\n\n        for (\n            let chunkIndex: number = 0;\n            chunkIndex < chunksCount;\n            ++chunkIndex, nextChunkStartIndex += chunkSize\n        ) {\n            chunks[chunkIndex] = string.substr(nextChunkStartIndex, chunkSize);\n        }\n\n        return chunks;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (!this.options.splitStrings) {\n                            return;\n                        }\n\n                        if (parentNode && NodeGuards.isLiteralNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (typeof literalNode.value !== 'string') {\n            return literalNode;\n        }\n\n        if (NodeGuards.isPropertyNode(parentNode) && !parentNode.computed && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (this.options.splitStringsChunkLength >= literalNode.value.length) {\n            return literalNode;\n        }\n\n        const stringChunks: string[] = SplitStringTransformer.chunkString(\n            literalNode.value,\n            this.options.splitStringsChunkLength\n        );\n\n        return this.transformStringChunksToBinaryExpressionNode(stringChunks);\n    }\n\n    /**\n     * @param {string[]} chunks\n     * @returns {BinaryExpression}\n     */\n    private transformStringChunksToBinaryExpressionNode (chunks: string[]): ESTree.BinaryExpression | ESTree.Literal {\n        const lastChunk: string | undefined = chunks.pop();\n\n        if (lastChunk === undefined) {\n            throw new Error('Last chunk value should not be empty');\n        }\n\n        const lastChunkLiteralNode: ESTree.Literal = NodeFactory.literalNode(lastChunk);\n\n        if (chunks.length === 0) {\n            return lastChunkLiteralNode;\n        }\n\n        return NodeFactory.binaryExpressionNode(\n            '+',\n            this.transformStringChunksToBinaryExpressionNode(chunks),\n            lastChunkLiteralNode\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node | null} parentNode\n     * @returns {boolean}\n     */\n    private static isValidTemplateLiteralNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.TemplateLiteral {\n        return NodeGuards.isTemplateLiteralNode(node) && !NodeGuards.isTaggedTemplateExpressionNode(parentNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && TemplateLiteralTransformer.isValidTemplateLiteralNode(node, parentNode)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(NodeFactory.literalNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(NodeFactory.literalNode(''));\n        }\n\n        let transformedNode: ESTree.Node;\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = NodeFactory.binaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = NodeFactory.binaryExpressionNode('+', root, node);\n            });\n\n            transformedNode = root;\n        } else {\n            transformedNode = nodes[0];\n        }\n\n        NodeUtils.parentizeAst(transformedNode);\n\n        return transformedNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class VariableDeclaratorPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {VariableDeclarator} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        if (\n            !NodeGuards.isIdentifierNode(hostNode.id)\n            || this.isProhibitedObjectExpressionNode(objectExpressionNode, hostNode.id)\n        ) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(objectExpressionNode, hostNode.id);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @returns {VariableDeclarator}\n     */\n    private getHostVariableDeclaratorNode (objectExpressionNode: ESTree.ObjectExpression): ESTree.VariableDeclarator | never {\n        const { parentNode } = objectExpressionNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclaratorNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclarator` node for `ObjectExpression` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {VariableDeclarator} variableDeclaratorNode\n     * @returns {VariableDeclaration}\n     */\n    private getHostVariableDeclarationNode (variableDeclaratorNode: ESTree.VariableDeclarator): ESTree.VariableDeclaration | never {\n        const { parentNode } = variableDeclaratorNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclarationNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclaration` node for `VariableDeclarator` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Identifier} memberExpressionHostNode\n     * @returns {boolean}\n     */\n    private isProhibitedObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Identifier\n    ): boolean {\n        const hostVariableDeclarator: ESTree.VariableDeclarator = this.getHostVariableDeclaratorNode(objectExpressionNode);\n        const hostVariableDeclaration: ESTree.VariableDeclaration = this.getHostVariableDeclarationNode(hostVariableDeclarator);\n        const { declarations } = hostVariableDeclaration;\n        const indexOfDeclarator: number = declarations.indexOf(hostVariableDeclarator);\n        const isLastDeclarator: boolean = indexOfDeclarator === (declarations.length - 1);\n\n        // avoid unnecessary checks\n        if (isLastDeclarator) {\n            return false;\n        }\n\n        const declaratorsAfterCurrentDeclarator: ESTree.VariableDeclarator[] = declarations.slice(indexOfDeclarator);\n\n        let isProhibitedObjectExpressionNode: boolean = false;\n\n        // should mark node as prohibited if that node using inside other variable declarators\n        declaratorsAfterCurrentDeclarator.forEach((variableDeclarator: ESTree.VariableDeclarator) => {\n            estraverse.traverse(variableDeclarator, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | ESTree.Node => {\n                    if (\n                        NodeGuards.isMemberExpressionNode(node)\n                        && NodeGuards.isIdentifierNode(node.object)\n                        && node.object.name === memberExpressionHostNode.name\n                    ) {\n                        isProhibitedObjectExpressionNode = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n\n                    return node;\n                }\n            });\n        });\n\n        return isProhibitedObjectExpressionNode;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { ObjectExpressionKeysTransformerCustomNode } from '../../../enums/custom-nodes/ObjectExpressionKeysTransformerCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BasePropertiesExtractorObjectExpressionHostNode } from '../../../custom-nodes/object-expression-keys-transformer-nodes/BasePropertiesExtractorObjectExpressionHostNode';\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { CustomNodeFormatter } from '../../../custom-nodes/CustomNodeFormatter';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // object expression keys transformer nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BasePropertiesExtractorObjectExpressionHostNode)\n        .whenTargetNamed(ObjectExpressionKeysTransformerCustomNode.BasePropertiesExtractorObjectExpressionHostNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.ICustomNodeFormatter,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions,\n                ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.ICustomNodeFormatter,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // object expression keys transformer customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IObjectExpressionKeysTransformerCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ObjectExpressionKeysTransformerCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.ICustomNodeFormatter,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions,\n                ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n\n    // custom node formatter\n    bind<ICustomNodeFormatter>(ServiceIdentifiers.ICustomNodeFormatter)\n        .to(CustomNodeFormatter)\n        .inSingletonScope();\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { ConsoleOutputDisableExpressionNode } from '../ConsoleOutputDisableExpressionNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode<TInitialData<ConsoleOutputDisableExpressionNode>> =\n            this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { DebugProtectionFunctionNode } from '../DebugProtectionFunctionNode';\nimport { DebugProtectionFunctionCallNode } from '../DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../DebugProtectionFunctionIntervalNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.append(nodeWithStatements, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = NodeGuards.isSwitchCaseNode(nodeWithStatements)\n                ? nodeWithStatements.consequent.length\n                : nodeWithStatements.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode<TInitialData<DebugProtectionFunctionNode>> =\n            this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode<TInitialData<DebugProtectionFunctionCallNode>> =\n            this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode<TInitialData<DebugProtectionFunctionIntervalNode>> =\n            this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { DomainLockNode } from '../DomainLockNode';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode<TInitialData<DomainLockNode>> =\n            this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeCallsControllerFunctionNode } from '../../node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../SelfDefendingUnicodeNode';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        const randomCallsGraphIndex: number = this.getRandomCallsGraphIndex(callsGraphData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                callsGraphData,\n                nodeWithStatements,\n                customNode.getNode(),\n                randomCallsGraphIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            const targetNodeWithStatements: TNodeWithStatements = callsGraphData.length\n                ? NodeAppender.getOptimalBlockScope(callsGraphData, randomCallsGraphIndex, 1)\n                : nodeWithStatements;\n\n            NodeAppender.prepend(targetNodeWithStatements, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode<TInitialData<SelfDefendingUnicodeNode>> =\n            this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode<TInitialData<NodeCallsControllerFunctionNode>> =\n            this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TInitialData } from '../../../types/TInitialData';\nimport { TNodeWithStatements } from '../../../types/node/TNodeWithStatements';\n\nimport { ICallsGraphData } from '../../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayStorage } from '../../../interfaces/storages/string-array-storage/IStringArrayStorage';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { StringArrayNode } from '../StringArrayNode';\nimport { StringArrayCallsWrapper } from '../StringArrayCallsWrapper';\nimport { StringArrayRotateFunctionNode } from '../StringArrayRotateFunctionNode';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {IStringArrayStorage}\n     */\n    private readonly stringArrayStorage: IStringArrayStorage;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {IStringArrayStorage} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: IStringArrayStorage,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithStatements} nodeWithStatements\n     * @param {ICallsGraphData[]} callsGraphData\n     */\n    public appendCustomNodes (nodeWithStatements: TNodeWithStatements, callsGraphData: ICallsGraphData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prepend(nodeWithStatements, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(nodeWithStatements, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode<TInitialData<StringArrayNode>> =\n            this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode<TInitialData<StringArrayCallsWrapper>> =\n            this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode<TInitialData<StringArrayRotateFunctionNode>> =\n            this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayName: string = this.stringArrayStorage.getStorageName();\n        const stringArrayCallsWrapperName: string = this.stringArrayStorage.getStorageCallsWrapperName();\n        const stringArrayRotationAmount: number = this.stringArrayStorage.getRotationAmount();\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotationAmount);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class BasePropertiesExtractorObjectExpressionHostNode extends AbstractCustomNode {\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    public initialize (): void {}\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.variableDeclarationNode(\n            [\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(\n                        this.identifierNamesGenerator.generate()\n                    ),\n                    NodeFactory.objectExpressionNode([])\n                )\n            ],\n            'const'\n        );\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        let that;\n        \n        try {\n            const getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        const getGlobal = function () {\n            let globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        const that = getGlobal();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.binaryExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.variableDeclarationNode(\n                [\n                    NodeFactory.variableDeclaratorNode(\n                        NodeFactory.identifierNode(controllerIdentifierName),\n                        NodeFactory.callExpressionNode(\n                            NodeFactory.memberExpressionNode(\n                                NodeFactory.literalNode(\n                                    this.originalKeysIndexesInShuffledArray.join('|')\n                                ),\n                                NodeFactory.identifierNode('split')\n                            ),\n                            [\n                                NodeFactory.literalNode('|')\n                            ]\n                        )\n                    )\n                ],\n                'const'\n            ),\n            NodeFactory.variableDeclarationNode(\n                [\n                    NodeFactory.variableDeclaratorNode(\n                        NodeFactory.identifierNode(indexIdentifierName),\n                        NodeFactory.literalNode(0)\n                    )\n                ],\n                'let'\n            ),\n            NodeFactory.whileStatementNode(\n                NodeFactory.literalNode(true),\n                NodeFactory.blockStatementNode([\n                    NodeFactory.switchStatementNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.identifierNode(controllerIdentifierName),\n                            NodeFactory.updateExpressionNode(\n                                '++',\n                                NodeFactory.identifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(NodeFactory.continueStatement());\n                            }\n\n                            return NodeFactory.switchCaseNode(\n                                NodeFactory.literalNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    NodeFactory.breakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.ifStatementNode(\n                NodeFactory.binaryExpressionNode(\n                    operator,\n                    NodeFactory.literalNode(leftString),\n                    NodeFactory.literalNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\n// tslint:disable\nimport { Expression } from 'estree';\n// tslint:enable\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = NodeFactory.identifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(NodeFactory.identifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.callExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {TControlFlowStorage}\n     */\n    @initializable()\n    private controlFlowStorage!: TControlFlowStorage;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: TControlFlowStorage): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return NodeFactory.propertyNode(\n                    NodeFactory.identifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = NodeFactory.variableDeclarationNode(\n            [\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()),\n                    NodeFactory.objectExpressionNode(propertyNodes)\n                )\n            ],\n            'const'\n        );\n\n        structure = NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return this.customNodeFormatter.formatTemplate(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        const {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            const func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    const c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.table = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.table = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\nimport format from 'string-template';\n\nimport { TObject } from '../types/TObject';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNodeFormatter } from '../interfaces/custom-nodes/ICustomNodeFormatter';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\n\nimport { NodeGuards } from '../node/NodeGuards';\n\n@injectable()\nexport class CustomNodeFormatter implements ICustomNodeFormatter {\n    /**\n     * @type {ESTree.VariableDeclaration['kind']}\n     */\n    private readonly prevailingKindOfVariables: ESTree.VariableDeclaration['kind'];\n\n    constructor (\n        @inject(ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)\n            prevailingKindOfVariablesAnalyzer: IPrevailingKindOfVariablesAnalyzer\n    ) {\n        this.prevailingKindOfVariables = prevailingKindOfVariablesAnalyzer.getPrevailingKind();\n    }\n\n    /**\n     * @param {string} template\n     * @param {TMapping} mapping\n     * @returns {string}\n     */\n    public formatTemplate <TMapping extends TObject> (\n        template: string,\n        mapping: TMapping\n    ): string {\n        return format(template, mapping);\n    }\n\n    /**\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    public formatStructure (statements: TStatement[]): TStatement[] {\n        for (const statement of statements) {\n            estraverse.replace(statement, {\n                enter: (node: ESTree.Node): ESTree.Node | void => {\n                    if (!NodeGuards.isVariableDeclarationNode(node)) {\n                        return;\n                    }\n\n                    if (this.prevailingKindOfVariables === 'var') {\n                        node.kind = 'var';\n                    }\n\n                    return node;\n                }\n            });\n        }\n\n        return statements;\n    }\n}\n","module.exports = require(\"string-template\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return this.customNodeFormatter.formatTemplate(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(\n                this,\n                function () {\n                    const regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                    const regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:[a-zA-Z_$][0-9a-zA-Z_$]*\\\\)', 'i');\n           \n                    const result = {debugProtectionFunctionName}('init');\n                    \n                    if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                        result('0');\n                    } else {\n                        {debugProtectionFunctionName}();\n                    }\n                }\n            )();\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return this.customNodeFormatter.formatTemplate(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return this.customNodeFormatter.formatTemplate(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            const func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {ICryptUtils} cryptUtils\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return this.customNodeFormatter.formatTemplate(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        const {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            const func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (let i = 0; i < 1000; i--) {\n                            const isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            const regExp = new RegExp(\"[{diff}]\", \"g\");\n            const domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            let document;\n            let domain;\n            let location;\n            let hostname;\n\n            for (let d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (let d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n\n            if (!(\"~\" > domain)) {\n                for (let d2 in that[document]) {\n                    if (d2.length == 8 && d2.charCodeAt(7) == 110 && d2.charCodeAt(0) == 108) {\n                        location = d2;\n                        \n                        break;\n                    }\n                }\n\n                for (let d3 in that[document][location]) {\n                    if (d3.length == 8 && d3.charCodeAt(7) == 101 && d3.charCodeAt(0) == 104) {\n                        hostname = d3;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            if (!document || !that[document]) {\n                return;\n            }\n            \n            const documentDomain = that[document][domain];\n            const documentLocationHostName = !!that[document][location] && that[document][location][hostname];\n            const currentDomain = documentDomain || documentLocationHostName;\n          \n            if (!currentDomain) {\n                return;\n            }\n          \n            let ok = false;\n                        \n            for (let i = 0; i < domains.length; i++) {\n                const domain = domains[i];\n                const position = currentDomain.length - domain.length;\n                const lastIndex = currentDomain.indexOf(domain, position);\n                const endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.logicalExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                this.customNodeFormatter.formatTemplate(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    identifiersDictionary: this.options.identifiersDictionary,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return this.customNodeFormatter.formatTemplate(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        const {singleNodeCallControllerFunctionName} = (function(){\n            let firstCall = true;\n            \n            return function (context, fn){\n                const rfn = firstCall ? function(){\n                    if(fn){\n                        const res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            this.customNodeFormatter.formatTemplate(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                identifiersDictionary: this.options.identifiersDictionary,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `е` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        const {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            const func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            const test1 = function () {\n                const regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            const test2 = function () {\n                const regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            const recursiveFunc1 = function (string) {\n                const i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            const recursiveFunc2 = function (string) {\n                const i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indеxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indеxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            this.customNodeFormatter.formatTemplate(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                identifiersDictionary: this.options.identifiersDictionary,\n                seed: this.randomGenerator.getRawSeed()\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = this.customNodeFormatter.formatTemplate(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = this.customNodeFormatter.formatTemplate(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = this.customNodeFormatter.formatTemplate(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = this.customNodeFormatter.formatTemplate(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    const str = String(input).replace(/=+$/, '');\n                    let output = '';\n                    for (\n                        let bc = 0, bs, buffer, idx = 0;\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                    return output;\n                }\n            );\n        })();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        const rc4 = function (str, key) {\n            let s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (let k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t     \n            let i;\n                    \t        \n\t        for (i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (let y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        const StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            const regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            const expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (let i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                const string = atob(str);\n                let newStringChars = [];\n                \n                for (let i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        const cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        const {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            let value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        const cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\nimport { IStringArrayStorage } from '../../interfaces/storages/string-array-storage/IStringArrayStorage';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {IStringArrayStorage}\n     */\n    @initializable()\n    private stringArrayStorage!: IStringArrayStorage;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {IStringArrayStorage} stringArrayStorage\n     * @param {string} stringArrayName\n     */\n    public initialize (\n        stringArrayStorage: IStringArrayStorage,\n        stringArrayName: string\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        return this.customNodeFormatter.formatTemplate(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        const {stringArrayName} = [{stringArray}];\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { NumberUtils } from '../../utils/NumberUtils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotationAmount!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotationAmount\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotationAmount: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotationAmount = stringArrayRotationAmount;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        return NodeUtils.convertCodeToStructure(nodeTemplate);\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getNodeTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = this.customNodeFormatter.formatTemplate(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            this.customNodeFormatter.formatTemplate(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotationAmount: NumberUtils.toHex(this.stringArrayRotationAmount),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                identifiersDictionary: this.options.identifiersDictionary,\n                seed: this.randomGenerator.getRawSeed()\n            }\n        ).getObfuscatedCode();\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        const selfDefendingFunc = function () {\n            const object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    let updatedCookie = name + \"=\" + value;\n                    let i = 0;\n                                                            \n                    for (let i = 0, len = options.length; i < len; i++) {\n                        const propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        const propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    const matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    const func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            const test1 = function () {\n                const regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            let cookie = '';\n            const result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            const {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotationAmount});\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.memberExpressionNode(\n                NodeFactory.identifierNode(this.controlFlowStorageName),\n                NodeFactory.identifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICustomNodeFormatter } from '../../interfaces/custom-nodes/ICustomNodeFormatter';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {ICustomNodeFormatter} customNodeFormatter\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.ICustomNodeFormatter) customNodeFormatter: ICustomNodeFormatter,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, customNodeFormatter, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @param {string} nodeTemplate\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (nodeTemplate: string): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.literalNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { DictionaryIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/DictionaryIdentifierNamesGenerator';\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(DictionaryIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    function identifierNameGeneratorFactory (): (context: interfaces.Context) => (options: IOptions) => IIdentifierNamesGenerator {\n        let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n        return (context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => (options: IOptions) => {\n            if (cachedIdentifierNamesGenerator) {\n                return cachedIdentifierNamesGenerator;\n            }\n\n            let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n            switch (options.identifierNamesGenerator) {\n                case IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator:\n                    identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                        ServiceIdentifiers.IIdentifierNamesGenerator,\n                        IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator\n                    );\n\n                    break;\n\n                case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                    identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                        ServiceIdentifiers.IIdentifierNamesGenerator,\n                        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                    );\n\n                    break;\n\n                case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                default:\n                    identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                        ServiceIdentifiers.IIdentifierNamesGenerator,\n                        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                    );\n            }\n\n            cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n            return identifierNamesGenerator;\n        };\n    }\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>(identifierNameGeneratorFactory());\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class DictionaryIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {Set<string>}\n     */\n    private identifierNamesSet: Set<string>;\n    \n    /**\n     * @type {IterableIterator<string>}\n     */\n    private identifiersIterator: IterableIterator<string>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IArrayUtils} arrayUtils\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n    ) {\n        super(randomGenerator, options);\n\n        this.arrayUtils = arrayUtils;\n        this.identifierNamesSet = new Set(this.getInitialIdentifierNames(this.options.identifiersDictionary));\n        this.identifiersIterator = this.identifierNamesSet.values();\n    }\n\n    /**\n     * @param {string} identifierName\n     * @returns {string | null}\n     */\n    private static incrementIdentifierName (identifierName: string): string | null {\n        let newIdentifierName: string = '';\n        let isSuccess: boolean = false;\n\n        for (const character of identifierName) {\n            if (!isSuccess && character === character.toUpperCase()) {\n                newIdentifierName += character.toLowerCase();\n            } else if (!isSuccess && character === character.toLowerCase()) {\n                newIdentifierName += character.toUpperCase();\n                isSuccess = true;\n            } else {\n                newIdentifierName += character;\n            }\n        }\n\n        if (isSuccess) {\n            return newIdentifierName;\n        }\n\n        return null;\n    }\n\n    public generate (): string {\n        if (!this.identifierNamesSet.size) {\n            throw new Error('Too many identifiers in the code, add more words to identifiers dictionary');\n        }\n\n        const iteratorResult: IteratorResult<string> = this.identifiersIterator.next();\n\n        if (!iteratorResult.done) {\n            return iteratorResult.value;\n        }\n\n        this.identifierNamesSet = new Set(this.getIncrementedIdentifierNames([...this.identifierNamesSet]));\n        this.identifiersIterator = this.identifierNamesSet.values();\n\n        return this.generate();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate();\n\n        return `${prefix}${identifierName}`.replace('__', '_');\n    }\n\n    /**\n     * @param {string[]} identifierNames\n     * @returns {string[]}\n     */\n    private getInitialIdentifierNames (identifierNames: string[]): string[] {\n        const formattedIdentifierNames: string[] = identifierNames\n            .filter(Boolean)\n            .map((identifierName: string) => identifierName.toLowerCase());\n\n        return this.arrayUtils.shuffle(formattedIdentifierNames);\n    }\n\n    /**\n     * @param {string[]} identifierNames\n     * @returns {string[]}\n     */\n    private getIncrementedIdentifierNames (identifierNames: string[]): string[] {\n        const formattedIdentifierNames: string[] = [];\n\n        for (const identifierName of identifierNames) {\n            const newIdentifierName: string | null = DictionaryIdentifierNamesGenerator\n                .incrementIdentifierName(identifierName);\n\n            if (newIdentifierName) {\n                formattedIdentifierNames.push(newIdentifierName);\n            }\n        }\n\n        return this.arrayUtils.shuffle(formattedIdentifierNames);\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { NumberUtils } from '../../utils/NumberUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = NumberUtils.toHex(randomInteger);\n        const prefixLength: number = Utils.hexadecimalPrefix.length + 1;\n        const baseNameLength: number = nameLength\n            ? nameLength - prefixLength\n            : HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength;\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, baseNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate(nameLength);\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const identifierName: string = this.generate(nameLength);\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * We can only ignore limited nameLength, it has no sense here\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generate (nameLength?: number): string {\n        const identifierName: string = this.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @param {number} nameLength\n     * @returns {string}\n     */\n    public generateWithPrefix (nameLength?: number): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate(nameLength);\n\n        return `${prefix}${identifierName}`;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (mangledName: string): boolean {\n        return super.isValidIdentifierName(mangledName)\n            && !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!this.isValidIdentifierName(newMangledName)) {\n            newMangledName = this.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { ScopeIdentifiersTransformer } from '../../../node-transformers/obfuscating-transformers/ScopeIdentifiersTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ScopeIdentifiersTransformer)\n        .whenTargetNamed(NodeTransformer.ScopeIdentifiersTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithLexicalScope } from '../../../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<TNodeWithLexicalScope, Map<string, string>>}\n     */\n    private readonly blockScopesMap: Map<TNodeWithLexicalScope, Map<string, string>> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {Identifier}\n     */\n    public replace (identifierNode: ESTree.Identifier, lexicalScopeNode: TNodeWithLexicalScope): ESTree.Identifier {\n        let identifierName: string = identifierNode.name;\n\n        if (this.blockScopesMap.has(lexicalScopeNode)) {\n            const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n            if (namesMap.has(identifierName)) {\n                identifierName = <string>namesMap.get(identifierName);\n            }\n        }\n\n        return NodeFactory.identifierNode(identifierName);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {Node} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeGlobalName (identifierNode: ESTree.Identifier, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const identifierName: string = identifierNode.name;\n\n        if (this.isReservedName(identifierName)) {\n            return;\n        }\n\n        const newIdentifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(identifierName, newIdentifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    public storeLocalName (identifierNode: ESTree.Identifier, lexicalScopeNode: TNodeWithLexicalScope): void {\n        const identifierName: string = identifierNode.name;\n\n        if (this.isReservedName(identifierName)) {\n            return;\n        }\n\n        const newIdentifierName: string = this.identifierNamesGenerator.generate();\n\n        if (!this.blockScopesMap.has(lexicalScopeNode)) {\n            this.blockScopesMap.set(lexicalScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(lexicalScopeNode);\n\n        namesMap.set(identifierName, newIdentifierName);\n    }\n\n    /**\n     * Preserve `name` to protect it from further using.\n     *\n     * @param {string} name\n     */\n    public preserveName (name: string): void {\n        this.identifierNamesGenerator.preserveName(name);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        if (!this.options.reservedNames.length) {\n            return false;\n        }\n\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            NodeFactory.arrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {SimpleLiteral} literalNode\n     * @returns {Node}\n     */\n    public replace (literalNode: ESTree.SimpleLiteral): ESTree.Node {\n        const literalValue: ESTree.SimpleLiteral['value'] = literalNode.value;\n\n        if (typeof literalValue !== 'boolean') {\n            throw new Error('`BooleanLiteralObfuscatingReplacer` should accept only literals with `boolean` value');\n        }\n\n        return literalValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeLexicalScopeUtils } from '../../node/NodeLexicalScopeUtils';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const lexicalScopeNode: TNodeWithLexicalScope | undefined = NodeLexicalScopeUtils.getLexicalScope(labeledStatementNode);\n\n        if (!lexicalScopeNode) {\n            return labeledStatementNode;\n        }\n\n        this.storeLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n        this.replaceLabeledStatementName(labeledStatementNode, lexicalScopeNode);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private storeLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label, lexicalScopeNode);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     */\n    private replaceLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node, lexicalScopeNode);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithLexicalScope } from '../types/node/TNodeWithLexicalScope';\n\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeLexicalScopeUtils {\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope}\n     */\n    public static getLexicalScope (node: ESTree.Node): TNodeWithLexicalScope | undefined {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    public static getLexicalScopes (node: ESTree.Node): TNodeWithLexicalScope[] {\n        return NodeLexicalScopeUtils.getLexicalScopesRecursive(node);\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithLexicalScope[]} nodesWithLexicalScope\n     * @param {number} depth\n     * @returns {TNodeWithLexicalScope[]}\n     */\n    private static getLexicalScopesRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        nodesWithLexicalScope: TNodeWithLexicalScope[] = [],\n        depth: number = 0\n    ): TNodeWithLexicalScope[] {\n        if (nodesWithLexicalScope.length >= maxSize) {\n            return nodesWithLexicalScope;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (NodeGuards.isNodeWithLexicalScope(node)) {\n            nodesWithLexicalScope.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeLexicalScopeUtils.getLexicalScopesRecursive(parentNode, maxSize, nodesWithLexicalScope, ++depth);\n        }\n\n        return nodesWithLexicalScope;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayStorageAnalyzer } from '../../interfaces/analyzers/string-array-storage-analyzer/IStringArrayStorageAnalyzer';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @type {IStringArrayStorageAnalyzer}\n     */\n    private readonly stringArrayStorageAnalyzer: IStringArrayStorageAnalyzer;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IStringArrayStorageAnalyzer} stringArrayStorageAnalyzer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IStringArrayStorageAnalyzer) stringArrayStorageAnalyzer: IStringArrayStorageAnalyzer\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n        this.stringArrayStorageAnalyzer = stringArrayStorageAnalyzer;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node);\n                        }\n\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !NodeMetadata.isReplacedLiteral(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    public analyzeNode (programNode: ESTree.Program): void {\n        this.stringArrayStorageAnalyzer.analyze(programNode);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (this.isProhibitedNode(literalNode, parentNode)) {\n            return literalNode;\n        }\n\n        let newLiteralNode: ESTree.Node;\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer\n                ).replace(literalNode);\n\n                break;\n\n            case 'number':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer\n                ).replace(literalNode);\n\n                break;\n\n            case 'string':\n                newLiteralNode = this.literalObfuscatingReplacerFactory(\n                    LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer\n                ).replace(literalNode);\n\n                break;\n\n            default:\n                newLiteralNode = literalNode;\n        }\n\n        NodeUtils.parentizeNode(newLiteralNode, parentNode);\n\n        return newLiteralNode;\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): boolean {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return true;\n        }\n\n        if (NodeGuards.isImportDeclarationNode(parentNode)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {SimpleLiteral} literalNode\n     * @returns {Node}\n     */\n    public replace (literalNode: ESTree.SimpleLiteral): ESTree.Node {\n        const literalValue: ESTree.SimpleLiteral['value'] = literalNode.value;\n\n        if (typeof literalValue !== 'number') {\n            throw new Error('`NumberLiteralObfuscatingReplacer` should accept only literals with `number` value');\n        }\n\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(literalValue)) {\n            rawValue = <string>this.numberLiteralCache.get(literalValue);\n        } else {\n            if (!NumberUtils.isCeil(literalValue)) {\n                rawValue = String(literalValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${NumberUtils.toHex(literalValue)}`;\n            }\n\n            this.numberLiteralCache.set(literalValue, rawValue);\n        }\n\n        return NodeFactory.literalNode(literalValue, rawValue);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IInitializable } from '../../../../interfaces/IInitializable';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IStringArrayStorage } from '../../../../interfaces/storages/string-array-storage/IStringArrayStorage';\nimport { IStringArrayStorageAnalyzer } from '../../../../interfaces/analyzers/string-array-storage-analyzer/IStringArrayStorageAnalyzer';\nimport { IStringArrayStorageItemData } from '../../../../interfaces/storages/string-array-storage/IStringArrayStorageItem';\n\nimport { initializable } from '../../../../decorators/Initializable';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeMetadata } from '../../../../node/NodeMetadata';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer implements IInitializable {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IStringArrayStorage}\n     */\n    private readonly stringArrayStorage: IStringArrayStorage;\n\n    /**\n     * @type {IStringArrayStorageAnalyzer}\n     */\n    private readonly stringArrayStorageAnalyzer: IStringArrayStorageAnalyzer;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayStorageCallsWrapperName!: string;\n\n    /**\n     * @param {IStringArrayStorage} stringArrayStorage\n     * @param {IStringArrayStorageAnalyzer} stringArrayStorageAnalyzer\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: IStringArrayStorage,\n        @inject(ServiceIdentifiers.IStringArrayStorageAnalyzer) stringArrayStorageAnalyzer: IStringArrayStorageAnalyzer,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayStorageAnalyzer = stringArrayStorageAnalyzer;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = NodeFactory.literalNode(hexadecimalIndex);\n\n        NodeMetadata.set(hexadecimalLiteralNode, { replacedLiteral: true });\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = NodeFactory.literalNode(literalValue);\n\n        NodeMetadata.set(rc4KeyLiteralNode, { replacedLiteral: true });\n\n        return rc4KeyLiteralNode;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.stringArrayStorageCallsWrapperName = this.stringArrayStorage.getStorageCallsWrapperName();\n\n        if (this.options.shuffleStringArray) {\n            this.stringArrayStorage.shuffleStorage();\n        }\n\n        if (this.options.rotateStringArray) {\n            this.stringArrayStorage.rotateStorage();\n        }\n    }\n\n    /**\n     * @param {SimpleLiteral} literalNode\n     * @returns {Node}\n     */\n    public replace (literalNode: ESTree.SimpleLiteral): ESTree.Node {\n        const literalValue: ESTree.SimpleLiteral['value'] = literalNode.value;\n\n        if (typeof literalValue !== 'string') {\n            throw new Error('`StringLiteralObfuscatingReplacer` should accept only literals with `string` value');\n        }\n\n        const stringArrayStorageItemData: IStringArrayStorageItemData | undefined = this.stringArrayStorageAnalyzer\n            .getItemDataForLiteralNode(literalNode);\n        const cacheKey: string = `${literalValue}-${Boolean(stringArrayStorageItemData)}`;\n        const useCachedValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCachedValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = stringArrayStorageItemData\n            ? this.replaceWithStringArrayCallNode(stringArrayStorageItemData)\n            : this.replaceWithLiteralNode(literalValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {IStringArrayStorageItemData} stringArrayStorageItemData\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (stringArrayStorageItemData: IStringArrayStorageItemData): ESTree.Node {\n        const { index, decodeKey } = stringArrayStorageItemData;\n\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${NumberUtils.toHex(index)}`;\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(hexadecimalIndex)\n        ];\n\n        if (decodeKey) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(decodeKey, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = NodeFactory.identifierNode(this.stringArrayStorageCallsWrapperName);\n\n        return NodeFactory.callExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as eslintScope from 'eslint-scope';\nimport * as ESTree from 'estree';\nimport * as estraverse from 'estraverse';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithLexicalScope } from '../../types/node/TNodeWithLexicalScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IScopeAnalyzer } from '../../interfaces/analyzers/scope-analyzer/IScopeAnalyzer';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Replaces all replaceable identifiers in scope\n */\n@injectable()\nexport class ScopeIdentifiersTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly argumentsVariableName: string = 'arguments';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalScopeNames: string[] = [\n        'global',\n        'module'\n    ];\n\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<TNodeWithLexicalScope, boolean>}\n     */\n    private readonly lexicalScopesWithObjectPatternWithoutDeclarationMap: Map<TNodeWithLexicalScope, boolean> = new Map();\n\n    /**\n     * @type {IScopeAnalyzer}\n     */\n    private readonly scopeAnalyzer: IScopeAnalyzer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {IScopeAnalyzer} scopeAnalyzer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.IScopeAnalyzer) scopeAnalyzer: IScopeAnalyzer\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n        this.scopeAnalyzer = scopeAnalyzer;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} programNode\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public analyzeNode (programNode: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.scopeAnalyzer.analyze(programNode);\n    }\n\n    /**\n     * @param {VariableDeclaration} programNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (programNode: ESTree.Program, parentNode: ESTree.Node): ESTree.Node {\n        const globalScope: eslintScope.Scope = this.scopeAnalyzer.acquireScope(programNode);\n\n        this.traverseScopeVariables(globalScope);\n\n        return programNode;\n    }\n\n    /**\n     * @param {Scope} scope\n     */\n    private traverseScopeVariables (scope: eslintScope.Scope): void {\n        const lexicalScope: eslintScope.Scope = scope.variableScope;\n        const nodeWithLexicalScope: TNodeWithLexicalScope | null = NodeGuards.isNodeWithBlockLexicalScope(lexicalScope.block)\n            ? lexicalScope.block\n            : null;\n        const isGlobalDeclaration: boolean = ScopeIdentifiersTransformer.globalScopeNames.includes(lexicalScope.type);\n\n        if (!nodeWithLexicalScope) {\n            return;\n        }\n\n        for (const variable of scope.variables) {\n            if (variable.name === ScopeIdentifiersTransformer.argumentsVariableName) {\n                continue;\n            }\n\n            if (!this.options.renameGlobals && isGlobalDeclaration) {\n                const isImportBindingOrCatchClauseIdentifier: boolean = variable.defs\n                    .every((definition: eslintScope.Definition) =>\n                        definition.type === 'ImportBinding'\n                        || definition.type === 'CatchClause'\n                    );\n\n                // skip all global identifiers except import statement and catch clause parameter identifiers\n                if (!isImportBindingOrCatchClauseIdentifier) {\n                    continue;\n                }\n            }\n\n            this.transformScopeVariableIdentifiers(variable, nodeWithLexicalScope, isGlobalDeclaration);\n        }\n\n        for (const childScope of scope.childScopes) {\n            this.traverseScopeVariables(childScope);\n        }\n    }\n\n    /**\n     * @param {Variable} variable\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private transformScopeVariableIdentifiers (\n        variable: eslintScope.Variable,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        for (const identifier of variable.identifiers) {\n            if (!this.isReplaceableIdentifierNode(identifier, lexicalScopeNode, variable)) {\n                continue;\n            }\n\n            this.storeIdentifierName(identifier, lexicalScopeNode, isGlobalDeclaration);\n            this.replaceIdentifierName(identifier, lexicalScopeNode, variable);\n        }\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeIdentifierName (\n        identifierNode: ESTree.Identifier,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(identifierNode, lexicalScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(identifierNode, lexicalScopeNode);\n        }\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Variable} variable\n     */\n    private replaceIdentifierName (\n        identifierNode: ESTree.Identifier,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        variable: eslintScope.Variable\n    ): void {\n        const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n            .replace(identifierNode, lexicalScopeNode);\n\n        identifierNode.name = newIdentifier.name;\n\n        // rename of references\n        variable.references.forEach((reference: eslintScope.Reference) => {\n            reference.identifier.name = identifierNode.name;\n        });\n\n        // rename of function default parameter identifiers if exists\n        (<any>variable.scope.block).defaults?.forEach((node: ESTree.Node) => {\n            if (NodeGuards.isIdentifierNode(node) && node.name === variable.name) {\n                node.name = identifierNode.name;\n            }\n        });\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @param {Variable} variable\n     * @returns {boolean}\n     */\n    private isReplaceableIdentifierNode (\n        identifierNode: ESTree.Identifier,\n        lexicalScopeNode: TNodeWithLexicalScope,\n        variable: eslintScope.Variable\n    ): identifierNode is ESTree.Identifier & { parentNode: ESTree.Node } {\n        const parentNode: ESTree.Node | undefined = identifierNode.parentNode;\n\n        return !!parentNode\n            && !NodeMetadata.isIgnoredNode(identifierNode)\n            && !this.isProhibitedPropertyNode(identifierNode, parentNode)\n            && !this.isProhibitedClassDeclarationNameIdentifierNode(variable, identifierNode, parentNode)\n            && !this.isProhibitedExportNamedClassDeclarationIdentifierNode(identifierNode, parentNode)\n            && !this.isProhibitedExportNamedFunctionDeclarationIdentifierNode(identifierNode, parentNode)\n            && !this.isProhibitedExportNamedVariableDeclarationIdentifierNode(identifierNode, parentNode)\n            && !this.isProhibitedImportSpecifierNode(identifierNode, parentNode)\n            && !this.isProhibitedVariableNameUsedInObjectPatternNode(variable, identifierNode, lexicalScopeNode)\n            && !NodeGuards.isLabelIdentifierNode(identifierNode, parentNode);\n    }\n\n    /**\n     * @param {Variable} variable\n     * @param {Identifier} identifierNode\n     * @param {Node} parentNode\n     * @returns {identifierNode is Identifier}\n     */\n    private isProhibitedClassDeclarationNameIdentifierNode (\n        variable: eslintScope.Variable,\n        identifierNode: ESTree.Identifier,\n        parentNode: ESTree.Node\n    ): identifierNode is ESTree.Identifier {\n        return NodeGuards.isClassDeclarationNode(variable.scope.block)\n            && NodeGuards.isClassDeclarationNode(parentNode)\n            && parentNode.id === identifierNode;\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {Node} parentNode\n     * @returns {identifierNode is Identifier}\n     */\n    private isProhibitedExportNamedClassDeclarationIdentifierNode (\n        identifierNode: ESTree.Identifier,\n        parentNode: ESTree.Node\n    ): identifierNode is ESTree.Identifier {\n        return NodeGuards.isClassDeclarationNode(parentNode)\n            && parentNode.id === identifierNode\n            && !!parentNode.parentNode\n            && NodeGuards.isExportNamedDeclarationNode(parentNode.parentNode);\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {Node} parentNode\n     * @returns {identifierNode is Identifier}\n     */\n    private isProhibitedExportNamedFunctionDeclarationIdentifierNode (\n        identifierNode: ESTree.Identifier,\n        parentNode: ESTree.Node\n    ): identifierNode is ESTree.Identifier {\n        return NodeGuards.isFunctionDeclarationNode(parentNode)\n            && parentNode.id === identifierNode\n            && !!parentNode.parentNode\n            && NodeGuards.isExportNamedDeclarationNode(parentNode.parentNode);\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {Node} parentNode\n     * @returns {identifierNode is Identifier}\n     */\n    private isProhibitedExportNamedVariableDeclarationIdentifierNode (\n        identifierNode: ESTree.Identifier,\n        parentNode: ESTree.Node\n    ): identifierNode is ESTree.Identifier {\n        return NodeGuards.isVariableDeclaratorNode(parentNode)\n            && parentNode.id === identifierNode\n            && !!parentNode.parentNode\n            && NodeGuards.isVariableDeclarationNode(parentNode.parentNode)\n            && !!parentNode.parentNode.parentNode\n            && NodeGuards.isExportNamedDeclarationNode(parentNode.parentNode.parentNode);\n    }\n\n    /**\n     * @param {Identifier} identifierNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedImportSpecifierNode (identifierNode: ESTree.Identifier, parentNode: ESTree.Node): boolean {\n        return NodeGuards.isImportSpecifierNode(parentNode)\n            && parentNode.imported.name === parentNode.local.name;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedPropertyNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        return NodeGuards.isPropertyNode(parentNode)\n            && !parentNode.computed\n            && parentNode.key === node;\n    }\n\n    /**\n     * Should not rename identifiers that used inside destructing assignment without declaration\n     *\n     * var a, b; // should not be renamed\n     * ({a, b} = {a: 1, b: 2});\n     *\n     * @param {Variable} variable\n     * @param {Identifier} identifierNode\n     * @param {TNodeWithLexicalScope} lexicalScopeNode\n     * @returns {boolean}\n     */\n    private isProhibitedVariableNameUsedInObjectPatternNode (\n        variable: eslintScope.Variable,\n        identifierNode: ESTree.Identifier,\n        lexicalScopeNode: TNodeWithLexicalScope\n    ): boolean {\n        let isLexicalScopeHasObjectPatternWithoutDeclaration: boolean | undefined =\n            this.lexicalScopesWithObjectPatternWithoutDeclarationMap.get(lexicalScopeNode);\n\n        // lexical scope was traversed before and object pattern without declaration was not found\n        if (isLexicalScopeHasObjectPatternWithoutDeclaration === false) {\n            return false;\n        }\n\n        const hasVarDefinitions: boolean = variable.defs.some((definition: eslintScope.Definition) => (<any>definition).kind === 'var');\n\n        if (!hasVarDefinitions) {\n            return false;\n        }\n\n        let isProhibitedVariableDeclaration: boolean = false;\n\n        estraverse.traverse(lexicalScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void | estraverse.VisitorOption => {\n                if (\n                    NodeGuards.isObjectPatternNode(node)\n                    && parentNode\n                    && NodeGuards.isAssignmentExpressionNode(parentNode)\n                ) {\n                    isLexicalScopeHasObjectPatternWithoutDeclaration = true;\n\n                    const properties: ESTree.Property[] = node.properties;\n\n                    for (const property of properties) {\n                        if (property.computed || !property.shorthand) {\n                            continue;\n                        }\n\n                        if (!NodeGuards.isIdentifierNode(property.key)) {\n                            continue;\n                        }\n\n                        if (identifierNode.name !== property.key.name) {\n                            continue;\n                        }\n\n                        isProhibitedVariableDeclaration = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n                }\n            }\n        });\n\n        this.lexicalScopesWithObjectPatternWithoutDeclarationMap.set(\n            lexicalScopeNode,\n            isLexicalScopeHasObjectPatternWithoutDeclaration ?? false\n        );\n\n        return isProhibitedVariableDeclaration;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n","import { TypeFromEnum } from '@gradecam/tsenum';\n\nimport { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayNotEmpty,\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator,\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: TypeFromEnum<typeof IdentifierNamesGenerator>;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    @ValidateIf((options: IOptions) =>\n        options.identifierNamesGenerator === IdentifierNamesGenerator.DictionaryIdentifierNamesGenerator\n    )\n    @ArrayNotEmpty()\n    public readonly identifiersDictionary!: string[];\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly inputFileName!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedStrings!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {string | number}\n     */\n    public readonly seed!: string | number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly shuffleStringArray!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: TypeFromEnum<typeof SourceMapMode>;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly splitStrings!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @ValidateIf((options: IOptions) => Boolean(options.splitStrings))\n    @Min(1)\n    public readonly splitStringsChunkLength!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.BrowserNoEval, ObfuscationTarget.Node])\n    public readonly target!: TypeFromEnum<typeof ObfuscationTarget>;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n","module.exports = require(\"class-validator\");","import { ValidationError } from 'class-validator';\n\nimport { TObject } from '../types/TObject';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} errors\n     * @returns {string}\n     */\n    public static format (errors: ValidationError[]): string {\n        return errors\n            .reduce(\n                (errorMessages: string[], error: ValidationError) => ([\n                    ...errorMessages,\n                    ValidationErrorsFormatter.formatWithNestedConstraints(error)\n                ]),\n                []\n            )\n            .join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} error\n     * @returns {string}\n     */\n    private static formatWithNestedConstraints (error: ValidationError): string {\n        const constraints: TObject<string> = error.constraints;\n\n        const rootError: string = `\\`${error.property}\\` errors:\\n`;\n        const nestedErrors: string = Object\n            .keys(constraints)\n            .map((constraint: string) => `    - ${constraints[constraint]}\\n`)\n            .join();\n\n        return `${rootError}${nestedErrors}`;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { InputFileNameRule } from './normalizer-rules/InputFileNameRule';\nimport { SeedRule } from './normalizer-rules/SeedRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { SplitStringsChunkLengthRule } from './normalizer-rules/SplitStringsChunkLengthRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        InputFileNameRule,\n        SeedRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        SplitStringsChunkLengthRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFrom(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringSeparator } from '../../enums/StringSeparator';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const InputFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { inputFileName } = options;\n\n    if (inputFileName) {\n        inputFileName = inputFileName\n            .replace(/^\\/+/, '')\n            .split(StringSeparator.Dot)\n            .slice(0, -1)\n            .join(StringSeparator.Dot) || inputFileName;\n\n        options = {\n            ...options,\n            inputFileName: `${inputFileName}.js`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SeedRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.seed) {\n        return {\n            ...options,\n            seed: options.seed\n        };\n    }\n\n    const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n        return Math.floor(Math.random() * (max - min + 1) + min);\n    };\n\n    return {\n        ...options,\n        seed: getRandomInteger(0, 999_999_999)\n    };\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringSeparator } from '../../enums/StringSeparator';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .replace(/(?:\\.js)?(?:\\.map)?$/, '');\n\n        let sourceMapFileNameParts: string[] = sourceMapFileName.split(StringSeparator.Dot);\n        const sourceMapFileNamePartsCount: number = sourceMapFileNameParts.length;\n        const lastPart: string = sourceMapFileNameParts[sourceMapFileNamePartsCount - 1];\n\n        // try to predict if last part is extension or not\n        if (sourceMapFileNamePartsCount > 1 && lastPart.length <= 3) {\n            sourceMapFileNameParts = sourceMapFileNameParts.slice(0, -1);\n        }\n\n        sourceMapFileName = sourceMapFileNameParts.join(StringSeparator.Dot);\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SplitStringsChunkLengthRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.splitStringsChunkLength === 0) {\n        options = {\n            ...options,\n            splitStrings: false,\n            splitStringsChunkLength: 0\n        };\n    } else {\n        options = {\n            ...options,\n            splitStringsChunkLength: Math.floor(options.splitStringsChunkLength)\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            shuffleStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvalCallExpressionTransformer';\nimport { MetadataTransformer } from '../../../node-transformers/preparing-transformers/MetadataTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\nimport { ReservedStringObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ReservedStringObfuscatingGuard';\nimport { VariablePreserveTransformer } from \"../../../node-transformers/preparing-transformers/VariablePreserveTransformer\";\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MetadataTransformer)\n        .whenTargetNamed(NodeTransformer.MetadataTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListObfuscatingGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentObfuscatingGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ReservedStringObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ReservedStringObfuscatingGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariablePreserveTransformer)\n        .whenTargetNamed(NodeTransformer.VariablePreserveTransformer);\n});\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport * as estraverse from \"estraverse\";\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { ConditionalCommentObfuscatingGuard } from \"./obfuscating-guards/ConditionalCommentObfuscatingGuard\";\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = [\n        '@license',\n        '@preserve'\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Initializing:\n                return {\n                    leave: (node: ESTree.Node) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            return this.transformNode(node);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     * Move comments to their nodes\n     *\n     * @param {Node} rootNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (rootNode: ESTree.Program): ESTree.Node {\n        if (!rootNode.comments || !rootNode.comments.length) {\n            return rootNode;\n        }\n\n        const comments: ESTree.Comment[] = this.transformComments(rootNode.comments);\n\n        if (comments.length === 0) {\n            return rootNode;\n        }\n\n        if (!rootNode.body.length) {\n            rootNode.leadingComments = comments;\n\n            return rootNode;\n        }\n\n        estraverse.traverse(rootNode, {\n            enter: (node: ESTree.Node): void => {\n                if (node === rootNode) {\n                    return;\n                }\n\n                const commentIdx: number = comments.findIndex((comment: ESTree.Comment) =>\n                    comment.range && node.range && comment.range[0] < node.range[0]\n                );\n\n                if (commentIdx === -1) {\n                    return;\n                }\n\n                node.leadingComments = comments.splice(commentIdx, comments.length - commentIdx).reverse();\n            }\n        });\n\n        if (comments.length > 0) {\n            rootNode.trailingComments = comments.reverse();\n        }\n\n        return rootNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((preservedWord: string) => comment.value.includes(preservedWord)) ||\n            ConditionalCommentObfuscatingGuard.isConditionalComment(comment)\n        ).reverse();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeGroupStorage } from '../../types/storages/TCustomNodeGroupStorage';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ICallsGraphAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphAnalyzer';\nimport { ICallsGraphData } from '../../interfaces/analyzers/calls-graph-analyzer/ICallsGraphData';\nimport { IPrevailingKindOfVariablesAnalyzer } from '../../interfaces/analyzers/calls-graph-analyzer/IPrevailingKindOfVariablesAnalyzer';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeGroupStorage}\n     */\n    private readonly customNodeGroupStorage: TCustomNodeGroupStorage;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {ICallsGraphAnalyzer}\n     */\n    private readonly callsGraphAnalyzer: ICallsGraphAnalyzer;\n\n    /**\n     * @type {ICallsGraphData[]}\n     */\n    private callsGraphData: ICallsGraphData[] = [];\n\n    /**\n     * @type {IPrevailingKindOfVariablesAnalyzer}\n     */\n    private readonly prevailingKindOfVariablesAnalyzer: IPrevailingKindOfVariablesAnalyzer;\n\n    /**\n     * @param {ICallsGraphAnalyzer} callsGraphAnalyzer\n     * @param {IPrevailingKindOfVariablesAnalyzer} prevailingKindOfVariablesAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {TCustomNodeGroupStorage} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ICallsGraphAnalyzer) callsGraphAnalyzer: ICallsGraphAnalyzer,\n        @inject(ServiceIdentifiers.IPrevailingKindOfVariablesAnalyzer)\n            prevailingKindOfVariablesAnalyzer: IPrevailingKindOfVariablesAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: TCustomNodeGroupStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.callsGraphAnalyzer = callsGraphAnalyzer;\n        this.prevailingKindOfVariablesAnalyzer = prevailingKindOfVariablesAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.callsGraphData = this.callsGraphAnalyzer.analyze(node);\n        this.prevailingKindOfVariablesAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.callsGraphData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.callsGraphData);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: ESTree.Statement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], NodeFactory.blockStatementNode(ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return NodeFactory.callExpressionNode(\n            NodeFactory.identifierNode('eval'),\n            [\n                NodeFactory.literalNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n","module.exports = require(\"js-string-escape\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds metadata properties to each node\n */\n@injectable()\nexport class MetadataTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        NodeMetadata.set(node, { ignoredNode: false });\n\n        if (NodeGuards.isLiteralNode(node)) {\n            NodeMetadata.set(node, { replacedLiteral: false });\n        }\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListObfuscatingGuard,\n        ObfuscatingGuard.ConditionalCommentObfuscatingGuard,\n        ObfuscatingGuard.ReservedStringObfuscatingGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        NodeMetadata.set(node, {\n            ignoredNode: !obfuscationAllowed\n        });\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n","import { inject, injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ReservedStringObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (\n            this.options.reservedStrings.length\n            && NodeGuards.isLiteralNode(node)\n            && typeof node.value === 'string'\n        ) {\n            return !this.isReservedString(node.value);\n        }\n\n        return true;\n    }\n\n    /**\n     * @param {string} value\n     * @returns {boolean}\n     */\n    private isReservedString (value: string): boolean {\n        return this.options.reservedStrings\n            .some((reservedString: string) => {\n                return new RegExp(reservedString, 'g').exec(value) !== null;\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\n\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Preserve non-replaceable variables\n */\n@injectable()\nexport class VariablePreserveTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            NodeGuards.isIdentifierNode(node)\n                            && parentNode\n                            && (\n                                NodeGuards.parentNodeIsPropertyNode(node, parentNode)\n                                || NodeGuards.parentNodeIsMemberExpressionNode(node, parentNode)\n                                || NodeGuards.parentNodeIsMethodDefinitionNode(node, parentNode)\n                                || NodeGuards.isLabelIdentifierNode(node, parentNode)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Identifier} node\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Identifier, parentNode: ESTree.Node): ESTree.Node {\n        this.identifierObfuscatingReplacer.preserveName(node.name);\n\n        return node;\n    }\n\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayStorage } from '../../../interfaces/storages/string-array-storage/IStringArrayStorage';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<IStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <string, ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <string, ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../interfaces/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayStorage } from '../../interfaces/storages/string-array-storage/IStringArrayStorage';\nimport { IStringArrayStorageItemData } from '../../interfaces/storages/string-array-storage/IStringArrayStorageItem';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class StringArrayStorage extends MapStorage <string, IStringArrayStorageItemData> implements IStringArrayStorage {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumRotationAmount: number = 100;\n\n    /**\n     * @type {number}\n     */\n    private static readonly maximumRotationAmount: number = 500;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {number}\n     */\n    private rotationAmount: number = 0;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayStorageName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayStorageCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     * @param {ICryptUtils} cryptUtils\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n        this.cryptUtils = cryptUtils;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringArrayStorage.rc4KeyLength\n                }),\n                StringArrayStorage.rc4KeysCount\n            );\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate(StringArrayStorage.stringArrayNameLength);\n\n        this.stringArrayStorageName = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        this.stringArrayStorageCallsWrapperName = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.rotationAmount = this.options.rotateStringArray\n            ? this.randomGenerator.getRandomInteger(\n                StringArrayStorage.minimumRotationAmount,\n                StringArrayStorage.maximumRotationAmount\n            )\n            : 0;\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IStringArrayStorageItemData}\n     */\n    public get (value: string): IStringArrayStorageItemData {\n        return this.getOrSetIfDoesNotExist(value);\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getRotationAmount (): number {\n        return this.rotationAmount;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.stringArrayStorageName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageName (): string {\n        return this.getStorageId();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageCallsWrapperName (): string {\n        return this.stringArrayStorageCallsWrapperName;\n    }\n\n    public rotateStorage (): void {\n        if (!this.getLength()) {\n            return;\n        }\n\n        this.storage = new Map(\n            this.arrayUtils.rotate(\n                Array.from(this.storage.entries()),\n                this.rotationAmount\n            )\n        );\n    }\n\n    public shuffleStorage (): void {\n        this.storage = new Map(\n            this.arrayUtils\n                .shuffle(Array.from(this.storage.entries()))\n                .map<[string, IStringArrayStorageItemData]>(\n                    (\n                        [value, stringArrayStorageItemData]: [string, IStringArrayStorageItemData],\n                        index: number\n                    ) => {\n                        stringArrayStorageItemData.index = index;\n\n                        return [value, stringArrayStorageItemData];\n                    }\n                )\n                .sort((\n                    [, stringArrayStorageItemDataA]: [string, IStringArrayStorageItemData],\n                    [, stringArrayStorageItemDataB]: [string, IStringArrayStorageItemData]\n                ) => stringArrayStorageItemDataA.index - stringArrayStorageItemDataB.index)\n        );\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return Array\n            .from(this.storage.values())\n            .map((stringArrayStorageItemData: IStringArrayStorageItemData) => {\n                return `'${this.escapeSequenceEncoder.encode(\n                    stringArrayStorageItemData.encodedValue,\n                    this.options.unicodeEscapeSequence\n                )}'`;\n            }).toString();\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IStringArrayStorageItemData}\n     */\n    private getOrSetIfDoesNotExist (value: string): IStringArrayStorageItemData {\n        const { encodedValue, decodeKey }: IEncodedValue = this.getEncodedValue(value);\n        const storedStringArrayStorageItemData: IStringArrayStorageItemData | undefined = this.storage.get(encodedValue);\n\n        if (storedStringArrayStorageItemData) {\n            return storedStringArrayStorageItemData;\n        }\n\n        const stringArrayStorageItemData: IStringArrayStorageItemData = {\n            encodedValue,\n            decodeKey,\n            value,\n            index: this.getLength()\n        };\n\n        this.storage.set(encodedValue, stringArrayStorageItemData);\n\n        return stringArrayStorageItemData;\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let decodeKey: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeKey = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, decodeKey));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, decodeKey };\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { ILevelledTopologicalSorter } from '../../../interfaces/utils/ILevelledTopologicalSorter';\nimport { INodeTransformerNamesGroupsBuilder } from '../../../interfaces/utils/INodeTransformerNamesGroupsBuilder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { LevelledTopologicalSorter } from '../../../utils/LevelledTopologicalSorter';\nimport { NodeTransformerNamesGroupsBuilder } from '../../../utils/NodeTransformerNamesGroupsBuilder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n\n    // levelled topological sorter\n    bind<ILevelledTopologicalSorter>(ServiceIdentifiers.ILevelledTopologicalSorter)\n        .to(LevelledTopologicalSorter);\n\n    // node transformer names groups builder\n    bind<INodeTransformerNamesGroupsBuilder>(ServiceIdentifiers.INodeTransformerNamesGroupsBuilder)\n        .to(NodeTransformerNamesGroupsBuilder)\n        .inSingletonScope();\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public createWithRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T | null}\n     */\n    public findMostOccurringElement <T extends string | number> (array: T[]): T | null {\n        const arrayLength: number = array.length;\n\n        if (!arrayLength) {\n            return null;\n        }\n\n        const elementsMap: Partial<{[key in T]: number}> = {};\n\n        let mostOccurringElement: T = array[0];\n        let mostOccurringElementCount: number = 1;\n\n        for (const element of array) {\n            const currentElementCount: number = elementsMap[element] ?? 0;\n            const updatedElementCount: number = currentElementCount + 1;\n\n            if (updatedElementCount > mostOccurringElementCount) {\n                mostOccurringElement = element;\n                mostOccurringElementCount = updatedElementCount;\n            }\n\n            elementsMap[element] = updatedElementCount;\n        }\n\n        return mostOccurringElement;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public rotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop();\n\n            if (temp) {\n                newArray.unshift(temp);\n            }\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public shuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    // tslint:disable\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    // tslint:enable\n\n    /**\n     * Hides string inside a other random string with larger length\n     *\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            ''\n        );\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    // tslint:disable\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    // tslint:enable\n}\n","module.exports = require(\"md5\");","module.exports = require(\"chance\");","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n        this.stringsCache.set(`${result}-${String(encodeAllSymbols)}`, result);\n\n        return result;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { ILevelledTopologicalSorter } from '../interfaces/utils/ILevelledTopologicalSorter';\n\ntype TVisitMark = 'ok' | 'visiting';\n\ninterface IVisitMarks <TValue extends string> {\n    [key: string]: TVisitMark;\n}\n\n/**\n * Port and rework of https://github.com/loveencounterflow/ltsort\n */\n@injectable()\nexport class LevelledTopologicalSorter <TValue extends string = string> implements ILevelledTopologicalSorter<TValue> {\n    /**\n     * @type {Map<TValue, TValue[]}\n     */\n    private readonly graph: Map<TValue, TValue[]> = new Map();\n\n    /**\n     * @param {TValue} precedent\n     * @param {TValue | null} consequent\n     * @returns {this}\n     */\n    public add (\n        precedent: TValue,\n        consequent: TValue | null = null\n    ): this {\n        if (consequent !== null) {\n            return this.link(precedent, consequent);\n        }\n\n        return this.register(precedent);\n    }\n\n    /**\n     * As given in http://en.wikipedia.org/wiki/Topological_sorting\n     *\n     * @returns {TValue[]}\n     */\n    public sort (): TValue[] {\n        const consequents: TValue[] = Array.from(this.graph.keys());\n\n        const results: TValue[] = [];\n        const marks: IVisitMarks<TValue> = {};\n\n        for (const consequent of consequents) {\n            if (marks[consequent] !== undefined) {\n                continue;\n            }\n\n            this.visit(results, marks, consequent);\n        }\n\n        return results;\n    }\n\n    /**\n     * @returns {TValue[][]}\n     */\n    public sortByGroups (): TValue[][] {\n        this.sort();\n\n        const resultItemsGroups: TValue[][] = [];\n\n        while (this.hasNodes()) {\n            const rootNodes: TValue[] = this.findRootNodes();\n\n            resultItemsGroups.push(rootNodes);\n\n            for (const rootNode of rootNodes) {\n                this.delete(rootNode);\n            }\n        }\n\n        return resultItemsGroups;\n    }\n\n    /**\n     * @param {TValue} consequent\n     */\n    private delete (consequent: TValue): void {\n        const precedents: TValue[] = this.getPrecedents(consequent);\n\n        if (precedents.length) {\n            throw new Error(`Unable to remove non-root node: ${consequent}`);\n        }\n\n        this.graph.delete(consequent);\n\n        const precedentsGroups: string[][] = Array.from(this.graph.values());\n\n        for (const precedentsGroup of precedentsGroups) {\n            const precedentsCount: number = precedentsGroup.length - 1;\n\n            for (let index: number = precedentsCount; index >= 0; index = index - 1) {\n                if (precedentsGroup[index] !== consequent) {\n                    continue;\n                }\n\n                precedentsGroup.splice(index, 1);\n            }\n        }\n    }\n\n    /**\n     * @returns {TValue[]}\n     */\n    private findRootNodes (): TValue[] {\n        const consequents: TValue[] = Array.from(this.graph.keys());\n        const rootNodes: TValue[] = [];\n\n        for (const consequent of consequents) {\n            if (!this.hasPrecedents(consequent)) {\n                rootNodes.push(consequent);\n            }\n        }\n\n        return rootNodes;\n    }\n\n    /**\n     * @param {TValue} consequent\n     * @returns {TValue[]}\n     */\n    private getPrecedents (consequent: TValue): TValue[] {\n        const precedents: TValue[] | undefined = this.graph.get(consequent);\n\n        if (!precedents) {\n            throw new Error(`Unknown node: ${consequent}`);\n        }\n\n        return precedents;\n    }\n\n    /**\n     * @returns {boolean}\n     */\n    private hasNodes (): boolean {\n        return this.graph.size > 0;\n    }\n\n    /**\n     * @param {TValue} consequent\n     * @returns {boolean}\n     */\n    private hasPrecedents (consequent: TValue): boolean {\n        return this.getPrecedents(consequent).length > 0;\n    }\n\n    /**\n     * @param {TValue} precedent\n     * @param {TValue} consequent\n     * @returns {this}\n     */\n    private link (precedent: TValue, consequent: TValue): this {\n        this.register(precedent);\n        this.register(consequent);\n\n        const target: TValue[] | undefined = this.graph.get(consequent);\n\n        if (target && !target.includes(precedent)) {\n            target.push(precedent);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {TValue} name\n     * @returns {this}\n     */\n    private register (name: TValue): this {\n        if (!this.graph.has(name)) {\n            this.graph.set(name, []);\n        }\n\n        return this;\n    }\n\n    /**\n     * @param {TValue[]} results\n     * @param {IVisitMarks<TValue>} marks\n     * @param {TValue} name\n     * @returns {null}\n     */\n    private visit (\n        results: TValue[],\n        marks: IVisitMarks<TValue>,\n        name: TValue\n    ): void {\n        const mark: TVisitMark = marks[name];\n\n        if (mark === 'visiting') {\n            throw new Error(`Detected cycle involving node: ${name}`);\n        }\n\n        if (mark) {\n            return;\n        }\n\n        marks[name] = 'visiting';\n\n        const precedents: TValue[] = this.getPrecedents(name);\n\n        for (const precedent of precedents) {\n            this.visit(results, marks, precedent);\n        }\n\n        marks[name] = 'ok';\n        results.push(name);\n\n        return;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TNodeTransformersRelationEdge } from '../types/node-transformers/TNodeTransformersRelationEdge';\nimport { TNormalizedNodeTransformers } from '../types/node-transformers/TNormalizedNodeTransformers';\n\nimport { ILevelledTopologicalSorter } from '../interfaces/utils/ILevelledTopologicalSorter';\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { INodeTransformerNamesGroupsBuilder } from '../interfaces/utils/INodeTransformerNamesGroupsBuilder';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\n\n@injectable()\nexport class NodeTransformerNamesGroupsBuilder implements INodeTransformerNamesGroupsBuilder {\n    /**\n     * @type {ILevelledTopologicalSorter<NodeTransformer>}\n     */\n    private readonly levelledTopologicalSorter: ILevelledTopologicalSorter<NodeTransformer>;\n\n    constructor (\n        @inject(ServiceIdentifiers.ILevelledTopologicalSorter)\n            levelledTopologicalSorter: ILevelledTopologicalSorter<NodeTransformer>\n    ) {\n        this.levelledTopologicalSorter = levelledTopologicalSorter;\n    }\n\n    /**\n     * Builds sorted NodeTransformer names by topological sort with levels\n     *\n     * For example, if SplitString transformer has following dependencies inside `runAfter` property:\n     *  - NodeTransformer.ObjectExpressionKeysTransformer,\n     *  - NodeTransformer.TemplateLiteralTransformer\n     *\n     *  Than result node transformer names groups will be like:\n     *  [\n     *      [\n     *          SomeTransformerA,\n     *          ObjectExpressionKeysTransformer,\n     *          TemplateLiteralTransformer,\n     *          SomeTransformerB\n     *      ],\n     *      [\n     *          SplitStringTransformer\n     *      ]\n     *  ]\n     *\n     * @param {TNormalizedNodeTransformers} normalizedNodeTransformers\n     * @returns {NodeTransformer[][]}\n     */\n    public build (normalizedNodeTransformers: TNormalizedNodeTransformers): NodeTransformer[][] {\n        const nodeTransformerNames: NodeTransformer[] = <NodeTransformer[]>Object.keys(normalizedNodeTransformers);\n        const relationEdges: TNodeTransformersRelationEdge[] = this.buildNodeTransformersRelationEdges(\n            nodeTransformerNames,\n            normalizedNodeTransformers\n        );\n\n        for (const [precedent, consequent] of relationEdges) {\n            this.levelledTopologicalSorter.add(precedent, consequent);\n        }\n\n        return this.levelledTopologicalSorter.sortByGroups();\n    }\n\n    /**\n     * @param {NodeTransformer[]} nodeTransformerNames\n     * @param {TNormalizedNodeTransformers} normalizedNodeTransformers\n     * @returns {[NodeTransformer, NodeTransformer][]}\n     */\n    private buildNodeTransformersRelationEdges (\n        nodeTransformerNames: NodeTransformer[],\n        normalizedNodeTransformers: TNormalizedNodeTransformers\n    ): TNodeTransformersRelationEdge[] {\n        const relationEdges: TNodeTransformersRelationEdge[] = [];\n\n        for (const nodeTransformerName of nodeTransformerNames) {\n            const nodeTransformer: INodeTransformer = normalizedNodeTransformers[nodeTransformerName];\n            const runAfterRelations: NodeTransformer[] | undefined = nodeTransformer.runAfter;\n\n            if (!runAfterRelations || !runAfterRelations.length) {\n                relationEdges.push([nodeTransformerName, null]);\n                continue;\n            }\n\n            for (const runAfterRelation of runAfterRelations) {\n                const isUnknownRelation: boolean = !normalizedNodeTransformers[runAfterRelation];\n\n                if (isUnknownRelation) {\n                    relationEdges.push([nodeTransformerName, null]);\n                    continue;\n                }\n\n                relationEdges.push([runAfterRelation, nodeTransformerName]);\n            }\n        }\n\n        return relationEdges;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as acorn from 'acorn';\nimport * as escodegen from 'escodegen';\nimport * as ESTree from 'estree';\n\nimport { TObfuscatedCodeFactory } from './types/container/source-code/TObfuscatedCodeFactory';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscatedCode } from './interfaces/source-code/IObfuscatedCode';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { ASTParserFacade } from './ASTParserFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {Options}\n     */\n    private static readonly parseOptions: acorn.Options = {\n        allowHashBang: true,\n        allowImportExportEverywhere: true,\n        allowReturnOutsideFunction: true,\n        ecmaVersion: 10,\n        locations: true,\n        ranges: true\n    };\n\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MetadataTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.ScopeIdentifiersTransformer,\n        NodeTransformer.SplitStringTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariablePreserveTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {TObfuscatedCodeFactory}\n     */\n    private readonly obfuscatedCodeFactory: TObfuscatedCodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {TObfuscatedCodeFactory} obfuscatedCodeFactory\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.Factory__IObfuscatedCode) obfuscatedCodeFactory: TObfuscatedCodeFactory,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.randomGenerator = randomGenerator;\n        this.obfuscatedCodeFactory = obfuscatedCodeFactory;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscatedCode}\n     */\n    public obfuscate (sourceCode: string): IObfuscatedCode {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, process.env.VERSION);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getInputSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscatedCode(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return ASTParserFacade.parse(sourceCode, JavaScriptObfuscator.parseOptions);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        astTree = this.runTransformationStage(astTree, TransformationStage.Initializing);\n\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments\n            && !astTree.trailingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = this.options.inputFileName || 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscatedCode}\n     */\n    private getObfuscatedCode (generatorOutput: IGeneratorOutput): IObfuscatedCode {\n        return this.obfuscatedCodeFactory(generatorOutput.code, generatorOutput.map);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n","import { decorate, injectable } from 'inversify';\nimport EventEmitter from 'eventemitter3';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n","module.exports = require(\"eventemitter3\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { IOptions } from '../interfaces/options/IOptions';\n\n@injectable()\nexport class ObfuscatedCode implements IObfuscatedCode {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    constructor (\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.correctObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    private correctObfuscatedCode (): string {\n        if (!this.sourceMap) {\n            return this.obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(this.sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return this.obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n        }\n\n        return `${this.obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n","import { ISourceCode } from '../interfaces/source-code/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @type {string}\n     */\n    private readonly sourceMap: string;\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} sourceMap\n     */\n    constructor (sourceCode: string, sourceMap: string) {\n        this.sourceCode = sourceCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.sourceCode;\n    }\n}\n","import { inject, injectable } from 'inversify';\n\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TNormalizedNodeTransformers } from '../types/node-transformers/TNormalizedNodeTransformers';\nimport { TTransformersRunnerData } from '../types/node-transformers/TTransformersRunnerData';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { INodeTransformerNamesGroupsBuilder } from '../interfaces/utils/INodeTransformerNamesGroupsBuilder';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\nimport { NodeMetadata } from '../node/NodeMetadata';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {Map<NodeTransformer[], TTransformersRunnerData>}\n     */\n    private readonly cachedNodeTransformersData: Map<NodeTransformer[], TTransformersRunnerData> = new Map();\n\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @type {INodeTransformerNamesGroupsBuilder}\n     */\n    private readonly nodeTransformerNamesGroupsBuilder: INodeTransformerNamesGroupsBuilder;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     * @param {INodeTransformerNamesGroupsBuilder} nodeTransformerNamesGroupsBuilder\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer)\n            nodeTransformerFactory: TNodeTransformerFactory,\n        @inject(ServiceIdentifiers.INodeTransformerNamesGroupsBuilder)\n            nodeTransformerNamesGroupsBuilder: INodeTransformerNamesGroupsBuilder,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n        this.nodeTransformerNamesGroupsBuilder = nodeTransformerNamesGroupsBuilder;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformerNames\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformerNames: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformerNames.length) {\n            return astTree;\n        }\n\n        let normalizedNodeTransformers: TNormalizedNodeTransformers;\n        let nodeTransformerNamesGroups: NodeTransformer[][];\n\n        if (!this.cachedNodeTransformersData.has(nodeTransformerNames)) {\n            normalizedNodeTransformers = this.buildNormalizedNodeTransformers(nodeTransformerNames);\n            nodeTransformerNamesGroups = this.nodeTransformerNamesGroupsBuilder.build(normalizedNodeTransformers);\n            this.cachedNodeTransformersData.set(nodeTransformerNames, [normalizedNodeTransformers, nodeTransformerNamesGroups]);\n        } else {\n            [\n                normalizedNodeTransformers,\n                nodeTransformerNamesGroups\n            ] = <TTransformersRunnerData>this.cachedNodeTransformersData.get(nodeTransformerNames);\n        }\n\n        for (const nodeTransformerNamesGroup of nodeTransformerNamesGroups) {\n            const enterVisitors: IVisitor[] = [];\n            const leaveVisitors: IVisitor[] = [];\n\n            for (const nodeTransformerName of nodeTransformerNamesGroup) {\n                const nodeTransformer: INodeTransformer = normalizedNodeTransformers[nodeTransformerName];\n                const visitor: IVisitor | null = nodeTransformer.getVisitor(transformationStage);\n\n                if (!visitor) {\n                    continue;\n                }\n\n                if (visitor.enter) {\n                    enterVisitors.push({ enter: visitor.enter });\n                }\n\n                if (visitor.leave) {\n                    leaveVisitors.push({ leave: visitor.leave });\n                }\n            }\n\n            if (!enterVisitors.length && !leaveVisitors.length) {\n                continue;\n            }\n\n            estraverse.replace(astTree, {\n                enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n                leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n            });\n        }\n\n        return astTree;\n    }\n\n    /**\n     * @param {NodeTransformer[]} nodeTransformerNames\n     * @returns {TNormalizedNodeTransformers}\n     */\n    private buildNormalizedNodeTransformers (nodeTransformerNames: NodeTransformer[]): TNormalizedNodeTransformers {\n        return nodeTransformerNames\n            .reduce<TNormalizedNodeTransformers>(\n                (acc: TNormalizedNodeTransformers, nodeTransformerName: NodeTransformer) => ({\n                    ...acc,\n                    [nodeTransformerName]: this.nodeTransformerFactory(nodeTransformerName)\n                }),\n                {}\n            );\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (NodeMetadata.isIgnoredNode(node)) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n","import * as commander from 'commander';\nimport * as path from 'path';\n\nimport { TInputCLIOptions } from '../types/options/TInputCLIOptions';\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TSourceCodeData } from '../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../interfaces/cli/IFileData';\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IObfuscatedCode } from '../interfaces/source-code/IObfuscatedCode';\n\nimport { initializable } from '../decorators/Initializable';\n\nimport { DEFAULT_PRESET } from '../options/presets/Default';\n\nimport { ArraySanitizer } from './sanitizers/ArraySanitizer';\nimport { BooleanSanitizer } from './sanitizers/BooleanSanitizer';\nimport { IdentifierNamesGeneratorSanitizer } from './sanitizers/IdentifierNamesGeneratorSanitizer';\nimport { ObfuscationTargetSanitizer } from './sanitizers/ObfuscatingTargetSanitizer';\nimport { SourceMapModeSanitizer } from './sanitizers/SourceMapModeSanitizer';\nimport { StringArrayEncodingSanitizer } from './sanitizers/StringArrayEncodingSanitizer';\n\nimport { CLIUtils } from './utils/CLIUtils';\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscatorFacade';\nimport { SourceCodeReader } from './utils/SourceCodeReader';\n\nexport class JavaScriptObfuscatorCLI implements IInitializable {\n    /**\n     * @type {BufferEncoding}\n     */\n    public static readonly encoding: BufferEncoding = 'utf8';\n\n    /**\n     * @type {string}\n     */\n    public static obfuscatedFilePrefix: string = '-obfuscated';\n\n    /**\n     * @type {string}\n     */\n    private static readonly baseIdentifiersPrefix: string = 'a';\n\n    /**\n     * @type {string[]}\n     */\n    private readonly arguments: string[];\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rawArguments: string[];\n\n    /**\n     * @type {commander.CommanderStatic}\n     */\n    @initializable()\n    private commands!: commander.CommanderStatic;\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    @initializable()\n    private inputCLIOptions!: TInputCLIOptions;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private inputPath!: string;\n\n    /**\n     * @param {string[]} argv\n     */\n    constructor (argv: string[]) {\n        this.rawArguments = argv;\n        this.arguments = argv.slice(2);\n    }\n\n    /**\n     * @param {TObject} options\n     * @returns {TInputOptions}\n     */\n    private static filterOptions (options: TInputCLIOptions): TInputOptions {\n        const filteredOptions: TInputOptions = {};\n\n        Object\n            .keys(options)\n            .forEach((option: keyof TInputCLIOptions) => {\n                if (options[option] === undefined) {\n                    return;\n                }\n\n                filteredOptions[option] = options[option];\n            });\n\n        return filteredOptions;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithoutSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const obfuscatedCode: string = JavaScriptObfuscator.obfuscate(sourceCode, options).getObfuscatedCode();\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {TInputOptions} options\n     */\n    private static processSourceCodeWithSourceMap (\n        sourceCode: string,\n        outputCodePath: string,\n        options: TInputOptions\n    ): void {\n        const outputSourceMapPath: string = CLIUtils.getOutputSourceMapPath(\n            outputCodePath,\n            options.sourceMapFileName || ''\n        );\n\n        options = {\n            ...options,\n            sourceMapFileName: path.basename(outputSourceMapPath)\n        };\n\n        const obfuscatedCode: IObfuscatedCode = JavaScriptObfuscator.obfuscate(sourceCode, options);\n\n        CLIUtils.writeFile(outputCodePath, obfuscatedCode.getObfuscatedCode());\n\n        if (options.sourceMapMode === 'separate' && obfuscatedCode.getSourceMap()) {\n            CLIUtils.writeFile(outputSourceMapPath, obfuscatedCode.getSourceMap());\n        }\n    }\n\n    public initialize (): void {\n        this.inputPath = path.normalize(this.arguments[0] || '');\n        this.commands = <commander.CommanderStatic>(new commander.Command());\n\n        this.configureCommands();\n        this.configureHelp();\n\n        this.inputCLIOptions = this.commands.opts();\n    }\n\n    public run (): void {\n        const canShowHelp: boolean = !this.arguments.length || this.arguments.includes('--help');\n\n        if (canShowHelp) {\n            this.commands.outputHelp();\n\n            return;\n        }\n\n        const sourceCodeData: TSourceCodeData = new SourceCodeReader(this.inputCLIOptions)\n            .readSourceCode(this.inputPath);\n\n        this.processSourceCodeData(sourceCodeData);\n    }\n\n    /**\n     * @returns {TInputOptions}\n     */\n    private buildOptions (): TInputOptions {\n        const inputCLIOptions: TInputOptions = JavaScriptObfuscatorCLI.filterOptions(this.inputCLIOptions);\n        const configFilePath: string | undefined = this.inputCLIOptions.config;\n        const configFileLocation: string = configFilePath ? path.resolve(configFilePath, '.') : '';\n        const configFileOptions: TInputOptions = configFileLocation ? CLIUtils.getUserConfig(configFileLocation) : {};\n        const inputFileName: string = path.basename(this.inputPath);\n\n        return {\n            ...DEFAULT_PRESET,\n            ...configFileOptions,\n            ...inputCLIOptions,\n            inputFileName\n        };\n    }\n\n    private configureCommands (): void {\n        this.commands\n            .usage('<inputPath> [options]')\n            .version(\n                process.env.VERSION || 'unknown',\n                '-v, --version'\n            )\n            .option(\n                '-o, --output <path>',\n                'Output path for obfuscated code'\n            )\n            .option(\n                '--compact <boolean>',\n                'Disable one line output code compacting',\n                BooleanSanitizer\n            )\n            .option(\n                '--config <boolean>',\n                'Name of js / json config file'\n            )\n            .option(\n                '--control-flow-flattening <boolean>',\n                'Enables control flow flattening',\n                BooleanSanitizer\n            )\n            .option(\n                '--control-flow-flattening-threshold <number>',\n                'The probability that the control flow flattening transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--dead-code-injection <boolean>',\n                'Enables dead code injection',\n                BooleanSanitizer\n            )\n            .option(\n                '--dead-code-injection-threshold <number>',\n                'The probability that the dead code injection transformation will be applied to the node',\n                parseFloat\n            )\n            .option(\n                '--debug-protection <boolean>',\n                'Disable browser Debug panel (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--debug-protection-interval <boolean>',\n                'Disable browser Debug panel even after page was loaded (can cause DevTools enabled browser freeze)',\n                BooleanSanitizer\n            )\n            .option(\n                '--disable-console-output <boolean>',\n                'Allow console.log, console.info, console.error and console.warn messages output into browser console',\n                BooleanSanitizer\n            )\n            .option(\n                '--domain-lock <list> (comma separated, without whitespaces)',\n                'Blocks the execution of the code in domains that do not match the passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--exclude <list> (comma separated, without whitespaces)',\n                'A filename or glob which indicates files to exclude from obfuscation',\n                ArraySanitizer\n            )\n            .option(\n                '--identifier-names-generator <string>',\n                'Sets identifier names generator. ' +\n                'Values: hexadecimal, mangled, dictionary. ' +\n                'Default: hexadecimal',\n                IdentifierNamesGeneratorSanitizer\n            )\n            .option(\n                '--identifiers-prefix <string>',\n                'Sets prefix for all global identifiers.'\n            )\n            .option(\n                '--identifiers-dictionary <list> (comma separated, without whitespaces)',\n                'Identifiers dictionary (comma separated) for `--identifier-names-generator dictionary` option',\n                ArraySanitizer\n            )\n            .option(\n                '--log <boolean>', 'Enables logging of the information to the console',\n                BooleanSanitizer\n            )\n            .option(\n                '--reserved-names <list> (comma separated, without whitespaces)',\n                'Disables obfuscation and generation of identifiers, which being matched by passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--reserved-strings <list> (comma separated, without whitespaces)',\n                'Disables transformation of string literals, which being matched by passed RegExp patterns (comma separated)',\n                ArraySanitizer\n            )\n            .option(\n                '--rename-globals <boolean>', 'Allows to enable obfuscation of global variable and function names with declaration.',\n                BooleanSanitizer\n            )\n            .option(\n                '--rotate-string-array <boolean>', 'Enable rotation of string array values during obfuscation',\n                BooleanSanitizer\n            )\n            .option(\n                '--seed <string|number>',\n                'Sets seed for random generator. This is useful for creating repeatable results.',\n                parseFloat\n            )\n            .option(\n                '--self-defending <boolean>',\n                'Disables self-defending for obfuscated code',\n                BooleanSanitizer\n            )\n            .option(\n                '--shuffle-string-array <boolean>', 'Randomly shuffles string array items',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map <boolean>',\n                'Enables source map generation',\n                BooleanSanitizer\n            )\n            .option(\n                '--source-map-base-url <string>',\n                'Sets base url to the source map import url when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-file-name <string>',\n                'Sets file name for output source map when `--source-map-mode=separate`'\n            )\n            .option(\n                '--source-map-mode <string>',\n                'Specify source map output mode. ' +\n                'Values: inline, separate. ' +\n                'Default: separate',\n                SourceMapModeSanitizer\n            )\n            .option(\n                '--split-strings <boolean>',\n                'Splits literal strings into chunks with length of `splitStringsChunkLength` option value',\n                BooleanSanitizer\n            )\n            .option(\n                '--split-strings-chunk-length <number>',\n                'Sets chunk length of `splitStrings` option',\n                parseFloat\n            )\n            .option(\n                '--string-array <boolean>',\n                'Disables gathering of all literal strings into an array and replacing every literal string with an array call',\n                BooleanSanitizer\n            )\n            .option(\n                '--string-array-encoding <string|boolean>',\n                'Encodes all strings in strings array using base64 or rc4 (this option can slow down your code speed. ' +\n                'Values: true, false, base64, rc4. ' +\n                'Default: false',\n                StringArrayEncodingSanitizer\n            )\n            .option(\n                '--string-array-threshold <number>',\n                'The probability that the literal string will be inserted into stringArray (Default: 0.8, Min: 0, Max: 1)',\n                parseFloat\n            )\n            .option(\n                '--target <string>',\n                'Allows to set target environment for obfuscated code. ' +\n                'Values: browser, browser-no-eval, node. ' +\n                'Default: browser',\n                ObfuscationTargetSanitizer\n            )\n            .option(\n                '--transform-object-keys <boolean>',\n                'Enables transformation of object keys',\n                BooleanSanitizer\n            )\n            .option(\n                '--unicode-escape-sequence <boolean>',\n                'Allows to enable/disable string conversion to unicode escape sequence',\n                BooleanSanitizer\n            )\n            .parse(this.rawArguments);\n    }\n\n    private configureHelp (): void {\n        this.commands.on('--help', () => {\n            console.log('  Examples:\\n');\n            console.log('    %> javascript-obfuscator input_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_file_name.js --output output_file_name.js --compact true --self-defending false');\n            console.log('    %> javascript-obfuscator input_directory_name --compact true --self-defending false');\n            console.log('');\n        });\n    }\n\n    /**\n     * @param {TSourceCodeData} sourceCodeData\n     */\n    private processSourceCodeData (sourceCodeData: TSourceCodeData): void {\n        const outputPath: string = this.inputCLIOptions.output\n            ? path.normalize(this.inputCLIOptions.output)\n            : '';\n\n        if (!Array.isArray(sourceCodeData)) {\n            const outputCodePath: string = outputPath || CLIUtils.getOutputCodePath(this.inputPath);\n\n            this.processSourceCode(sourceCodeData, outputCodePath, null);\n        } else {\n            sourceCodeData.forEach(({ filePath, content }: IFileData, index: number) => {\n                const outputCodePath: string = outputPath\n                    ? path.join(outputPath, filePath)\n                    : CLIUtils.getOutputCodePath(filePath);\n\n                this.processSourceCode(content, outputCodePath, index);\n            });\n        }\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} outputCodePath\n     * @param {number | null} sourceCodeIndex\n     */\n    private processSourceCode (\n        sourceCode: string,\n        outputCodePath: string,\n        sourceCodeIndex: number | null\n    ): void {\n        let options: TInputOptions = this.buildOptions();\n\n        if (sourceCodeIndex !== null) {\n            const baseIdentifiersPrefix: string = this.inputCLIOptions.identifiersPrefix\n                || JavaScriptObfuscatorCLI.baseIdentifiersPrefix;\n            const identifiersPrefix: string = `${baseIdentifiersPrefix}${sourceCodeIndex}`;\n\n            options = {\n                ...options,\n                identifiersPrefix\n            };\n        }\n\n        if (options.sourceMap) {\n            JavaScriptObfuscatorCLI.processSourceCodeWithSourceMap(sourceCode, outputCodePath, options);\n        } else {\n            JavaScriptObfuscatorCLI.processSourceCodeWithoutSourceMap(sourceCode, outputCodePath, options);\n        }\n    }\n}\n","module.exports = require(\"path\");","module.exports = require(\"fs\");","\"use strict\";\n\nimport { JavaScriptObfuscatorCLI } from './src/JavaScriptObfuscatorCLIFacade';\n\nmodule.exports = JavaScriptObfuscatorCLI;\n","import 'reflect-metadata';\n\nimport { JavaScriptObfuscatorCLI } from './cli/JavaScriptObfuscatorCLI';\n\nclass JavaScriptObfuscatorCLIFacade {\n    /**\n     * @param {string[]} argv\n     */\n    public static obfuscate (argv: string[]): void {\n        const javaScriptObfuscatorCLI: JavaScriptObfuscatorCLI = new JavaScriptObfuscatorCLI(argv);\n\n        javaScriptObfuscatorCLI.initialize();\n        javaScriptObfuscatorCLI.run();\n    }\n}\n\nexport { JavaScriptObfuscatorCLIFacade as JavaScriptObfuscatorCLI };\n","module.exports = require(\"commander\");","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {string[]}\n */\nexport const ArraySanitizer: TCLISanitizer <string[]> = (value: string): string[] => {\n    if (/,$/.test(value)) {\n        throw new SyntaxError(`Multiple <list> values should be wrapped inside quotes: --option-name 'value1','value2'`);\n    }\n\n    return value.split(',').map((string: string) => string.trim());\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nexport const BooleanSanitizer: TCLISanitizer <boolean> = (value: string): boolean => {\n    return value === 'true' || value === '1';\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const IdentifierNamesGeneratorSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectIdentifierNamesGenerator: boolean = Object\n        .keys(IdentifierNamesGenerator)\n        .some((key: string): boolean => {\n            return IdentifierNamesGenerator[<keyof typeof IdentifierNamesGenerator>key] === value;\n        });\n\n    if (!isCorrectIdentifierNamesGenerator) {\n        throw new ReferenceError('Invalid value of `--identifier-names-generator` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const ObfuscationTargetSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectTarget: boolean = Object\n        .keys(ObfuscationTarget)\n        .some((key: string): boolean => {\n            return ObfuscationTarget[<keyof typeof ObfuscationTarget>key] === value;\n        });\n\n    if (!isCorrectTarget) {\n        throw new ReferenceError('Invalid value of `--target` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\n\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\n/**\n * @param {string} value\n * @returns {string}\n */\nexport const SourceMapModeSanitizer: TCLISanitizer <string> = (value: string): string => {\n    const isCorrectSourceMapMode: boolean = Object\n        .keys(SourceMapMode)\n        .some((key: string): boolean => {\n            return SourceMapMode[<keyof typeof SourceMapMode>key] === value;\n        });\n\n    if (!isCorrectSourceMapMode) {\n        throw new ReferenceError('Invalid value of `--source-map-mode` option');\n    }\n\n    return value;\n};\n","import { TCLISanitizer } from '../../types/cli/TCLISanitizer';\nimport { TStringArrayEncoding } from '../../types/options/TStringArrayEncoding';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {string} value\n * @returns {TStringArrayEncoding}\n */\nexport const StringArrayEncodingSanitizer: TCLISanitizer <TStringArrayEncoding> = (value: string): TStringArrayEncoding => {\n    switch (value) {\n        case 'true':\n        case '1':\n        case StringArrayEncoding.Base64:\n            return true;\n\n        case StringArrayEncoding.Rc4:\n            return StringArrayEncoding.Rc4;\n\n        default:\n            return false;\n    }\n};\n","import * as fs from 'fs';\nimport * as mkdirp from 'mkdirp';\nimport * as path from 'path';\n\nimport { TObject } from '../../types/TObject';\n\nimport { StringSeparator } from '../../enums/StringSeparator';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\n\nexport class CLIUtils {\n    /**\n     * @param {string} inputPath\n     * @returns {string}\n     */\n    public static getOutputCodePath (inputPath: string): string {\n        return path\n            .normalize(inputPath)\n            .split(StringSeparator.Dot)\n            .map((value: string, index: number) => {\n                return index === 0 ? `${value}${JavaScriptObfuscatorCLI.obfuscatedFilePrefix}` : value;\n            })\n            .join(StringSeparator.Dot);\n    }\n\n    /**\n     * @param {string} outputCodePath\n     * @param {string} sourceMapFileName\n     * @returns {string}\n     */\n    public static getOutputSourceMapPath (outputCodePath: string, sourceMapFileName: string = ''): string {\n        if (sourceMapFileName) {\n            outputCodePath = `${outputCodePath.substring(\n                0, outputCodePath.lastIndexOf('/')\n            )}/${sourceMapFileName}`;\n        }\n\n        if (!/\\.js\\.map$/.test(outputCodePath)) {\n            outputCodePath = `${outputCodePath.split(StringSeparator.Dot)[0]}.js.map`;\n        } else if (/\\.js$/.test(outputCodePath)) {\n            outputCodePath += '.map';\n        }\n\n        return outputCodePath;\n    }\n\n    /**\n     * @param {string} configPath\n     * @returns {TObject}\n     */\n    public static getUserConfig (configPath: string): TObject {\n        let config: TObject;\n\n        try {\n            config = require(configPath);\n        } catch {\n            try {\n                config = __non_webpack_require__(configPath);\n            } catch {\n                throw new ReferenceError('Given config path must be a valid `.js` or `.json` file path');\n            }\n        }\n\n        return config;\n    }\n\n    /**\n     * @param {string} outputPath\n     * @param {string} data\n     */\n    public static writeFile (outputPath: string, data: string): void {\n        mkdirp.sync(path.dirname(outputPath));\n\n        fs.writeFileSync(outputPath, data, {\n            encoding: JavaScriptObfuscatorCLI.encoding\n        });\n    }\n}\n","module.exports = require(\"mkdirp\");","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 213;","import * as fs from 'fs';\nimport * as path from 'path';\nimport multimatch from 'multimatch';\n\nimport { TInputCLIOptions } from '../../types/options/TInputCLIOptions';\nimport { TSourceCodeData } from '../../types/cli/TSourceCodeData';\n\nimport { IFileData } from '../../interfaces/cli/IFileData';\n\nimport { LoggingPrefix } from '../../enums/logger/LoggingPrefix';\n\nimport { JavaScriptObfuscatorCLI } from '../JavaScriptObfuscatorCLI';\nimport { Logger } from '../../logger/Logger';\n\nexport class SourceCodeReader {\n    /**\n     * @type {string[]}\n     */\n    public static readonly availableInputExtensions: string[] = [\n        '.js'\n    ];\n\n    /**\n     * @type {TInputCLIOptions}\n     */\n    private readonly options: TInputCLIOptions;\n\n    /**\n     * @param {TInputCLIOptions} options\n     */\n    constructor (options: TInputCLIOptions) {\n        this.options = options;\n    }\n\n    /**\n     * @param {string} filePath\n     * @param {string[]} excludePatterns\n     * @returns {boolean}\n     */\n    private static isExcludedPath (filePath: string, excludePatterns: string[] = []): boolean {\n        if (!excludePatterns.length) {\n            return false;\n        }\n\n        const fileName: string = path.basename(filePath);\n        const isExcludedFilePathByGlobPattern: boolean = !!multimatch([filePath], excludePatterns).length;\n        const isExcludedFilePathByInclusion: boolean = excludePatterns.some((excludePattern: string) =>\n            filePath.includes(excludePattern) || fileName.includes(excludePattern)\n        );\n\n        return isExcludedFilePathByInclusion || isExcludedFilePathByGlobPattern;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isDirectoryPath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isDirectory();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private static isFilePath (filePath: string): boolean {\n        try {\n            return fs.statSync(filePath).isFile();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * @param {string} filePath\n     */\n    private static logFilePath (filePath: string): void {\n        const normalizedFilePath: string = path.normalize(filePath);\n\n        Logger.log(\n            Logger.colorInfo,\n            LoggingPrefix.CLI,\n            `Obfuscating file: ${normalizedFilePath}...`\n        );\n    }\n\n    /**\n     * @param {string} inputPath\n     * @returns {TSourceCodeData}\n     */\n    public readSourceCode (inputPath: string): TSourceCodeData {\n        if (SourceCodeReader.isFilePath(inputPath) && this.isValidFile(inputPath)) {\n            return this.readFile(inputPath);\n        }\n\n        if (SourceCodeReader.isDirectoryPath(inputPath) && this.isValidDirectory(inputPath)) {\n            return this.readDirectoryRecursive(inputPath);\n        }\n\n        const availableFilePaths: string = SourceCodeReader\n            .availableInputExtensions\n            .map((extension: string) => `\\`${extension}\\``)\n            .join(', ');\n\n        throw new ReferenceError(`Given input path must be a valid ${availableFilePaths} file or directory path`);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @param {IFileData[]} fileData\n     * @returns {IFileData[]}\n     */\n    private readDirectoryRecursive (directoryPath: string, fileData: IFileData[] = []): IFileData[] {\n        fs.readdirSync(directoryPath, JavaScriptObfuscatorCLI.encoding)\n            .forEach((fileName: string) => {\n                const filePath: string = `${directoryPath}/${fileName}`;\n\n                if (SourceCodeReader.isDirectoryPath(filePath) && this.isValidDirectory(filePath)) {\n                    fileData.push(...this.readDirectoryRecursive(filePath));\n                } else if (SourceCodeReader.isFilePath(filePath) && this.isValidFile(filePath)) {\n                    const content: string = this.readFile(filePath);\n\n                    fileData.push({ filePath, content });\n                }\n            });\n\n        return fileData;\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {string}\n     */\n    private readFile (filePath: string): string {\n        SourceCodeReader.logFilePath(filePath);\n\n        return fs.readFileSync(filePath, JavaScriptObfuscatorCLI.encoding);\n    }\n\n    /**\n     * @param {string} directoryPath\n     * @returns {boolean}\n     */\n    private isValidDirectory (directoryPath: string): boolean {\n        return !SourceCodeReader.isExcludedPath(directoryPath, this.options.exclude);\n    }\n\n    /**\n     * @param {string} filePath\n     * @returns {boolean}\n     */\n    private isValidFile (filePath: string): boolean {\n        return SourceCodeReader.availableInputExtensions.includes(path.extname(filePath))\n            && !filePath.includes(JavaScriptObfuscatorCLI.obfuscatedFilePrefix)\n            && !SourceCodeReader.isExcludedPath(filePath, this.options.exclude);\n    }\n}\n","module.exports = require(\"multimatch\");"],"sourceRoot":""}